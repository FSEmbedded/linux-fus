/*
 * Copyright (C) 2015 F&S Elektronik Systeme GmbH
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 */

#define CONFIG_EFUSA9X_BL_LEVELS_16
#define CONFIG_EFUSA9X_WLAN

/* Please select only one of the following touch devices. Make sure that the
   corresponding touchscreen driver is activated in the kernel */
//#define CONFIG_EFUSA9X_4WTOUCH_SX8655_ONBOARD
#define CONFIG_EFUSA9X_4WTOUCH_SX8655_RGBADAPTER
//#define CONFIG_EFUSA9X_CAPTOUCH_MXT224
//#define CONFIG_EFUSA9X_CAPTOUCH_FT5x06

/dts-v1/;

/* If UART_C uses RTS, we can only have one CS on SPI_B; if UART_C does
   not need RTS, we can have a second CS on SPI_B */
#define CONFIG_EFUSA9X_UART_C_RTS

#include "imx6sx.dtsi"
#include <dt-bindings/pwm/pwm.h>
/ {
	model = "F&S efusA9X";
	compatible = "fus,imx6sx-efusa9x", "fsl,imx6sx";

	backlight_lcd {
		compatible = "pwm-backlight";
		pwms = <&pca963x 1 640000 PWM_POLARITY_INVERTED>;
		power-supply = <&reg_lcd_bl>;
#ifdef CONFIG_EFUSA9X_BL_LEVELS_16
		brightness-levels = <0 1 5 10 18 28 41 56
				     73 92 113 137 163 192 222 255>;
		default-brightness-level = <14>;
#else
		brightness-levels = <0 5 21 47 83 130 187 255>;
		default-brightness-level = <6>;
#endif
		fb-names = "mxs-lcdif1";
	};

	backlight_ldb {
		compatible = "pwm-backlight";
		pwms = <&pwm6 0 5000000>;
		power-supply = <&reg_ldb_bl>;
#ifdef CONFIG_EFUSA9X_BL_LEVELS_16
		brightness-levels = <0 1 5 10 18 28 41 56
				     73 92 113 137 163 192 222 255>;
		default-brightness-level = <14>;
#else
		brightness-levels = <0 5 21 47 83 130 187 255>;
		default-brightness-level = <6>;
#endif
		fb-names = "mxs-lcdif2";
	};

	clocks {
		codec_osc: anaclk2 {
			#clock-cells = <0>;
			compatible = "fixed-clock";
			clock-frequency = <24576000>;
		};
	};

#if 0 //###
	/* ### Versuch, die Reset-Leitung f√ºr EMMC zu toggeln */
	emmc_reset: emmc-reset {
		compatible = "gpio-reset";
		reset-gpios = <&gpio6 22 GPIO_ACTIVE_LOW>;
		reset-delay-us = <1>;
		#reset-cells = <0>;
	};
#endif

	memory {
		reg = <0x80000000 0x80000000>;
	};

	pxp_v4l2_out {
		compatible = "fsl,imx6sx-pxp-v4l2", "fsl,imx6sl-pxp-v4l2";
		status = "okay";
	};

	regulators {
		compatible = "simple-bus";

		/* SGTL5000 analog voltage */
		reg_sgtl5000_vdda: sgtl5000_vdda {
			compatible = "regulator-fixed";
			regulator-name = "VDDA-supply";
			regulator-min-microvolt = <3000000>;
			regulator-max-microvolt = <3000000>;
			regulator-always-on;
		};

		/* SGTL5000 I/O voltage */
		reg_sgtl5000_vddio: sgtl5000_vddio {
			compatible = "regulator-fixed";
			regulator-name = "VDDIO-supply";
			regulator-min-microvolt = <3300000>;
			regulator-max-microvolt = <3300000>;
			regulator-always-on;
		};

		/* SGTL5000 internal digital voltage */
		reg_sgtl5000_vddd: sgtl5000_vddd {
			compatible = "regulator-fixed";
			regulator-name = "VDDD-supply";
			regulator-min-microvolt = <1500000>;
			regulator-max-microvolt = <1500000>;
			regulator-always-on;
		};

		reg_disp_3v3: disp-3v3 {
			compatible = "regulator-fixed";
			regulator-name = "disp-3v3";
			gpio = <&gpio3 19 0>;
			regulator-min-microvolt = <3300000>;
			regulator-max-microvolt = <3300000>;
			enable-active-high;
		};

		reg_lcd_bl: lcd-bl {
			compatible = "regulator-fixed";
			regulator-name = "lcd-bl";
			gpio = <&pca963x 0 0>;
			regulator-min-microvolt = <3300000>;
			regulator-max-microvolt = <3300000>;
		};

		reg_ldb_bl: ldb-bl {
			compatible = "regulator-fixed";
			regulator-name = "ldb-bl";
			gpio = <&gpio3 20 0>;
			regulator-min-microvolt = <3300000>;
			regulator-max-microvolt = <3300000>;
			enable-active-high;
		};

		reg_camera_dovdd: camera_dovdd {
			compatible = "regulator-fixed";
			regulator-name = "DOVDD-supply";
			regulator-min-microvolt = <1800000>;
			regulator-max-microvolt = <1800000>;
		};

		reg_camera_avdd: camera_avdd {
			compatible = "regulator-fixed";
			regulator-name = "VAVDD-supply";
			regulator-min-microvolt = <2800000>;
			regulator-max-microvolt = <2800000>;
		};

		reg_camera_dvdd: camera_dvdd {
			compatible = "regulator-fixed";
			regulator-name = "DVDD-supply";
			regulator-min-microvolt = <1500000>;
			regulator-max-microvolt = <1500000>;
		};

#if 0
		reg_atmel_mxt_vdd: atmel_mxt_vdd {
			compatible = "regulator-fixed";
			regulator-name = "mxt-3v3";
			status = "enabled";
		};

		reg_atmel_mxt_avdd: atmel_mxt_avdd {
			compatible = "regulator-fixed";
			regulator-name = "mxt-3v3";
			status = "enabled";
		};
#endif

		reg_vref_3v3: regulator@0 {
			compatible = "regulator-fixed";
			regulator-name = "vref-3v3";
			regulator-min-microvolt = <3300000>;
			regulator-max-microvolt = <3300000>;
		};


		reg_usb_otg1_vbus: usb_otg1_vbus {
			compatible = "regulator-fixed";
			regulator-name = "usb_otg1_vbus";
			regulator-min-microvolt = <5000000>;
			regulator-max-microvolt = <5000000>;
			gpio = <&gpio1 9 0>;
			enable-active-high;
		};

		reg_usb_otg2_vbus: usb_otg2_vbus {
			compatible = "regulator-fixed";
			regulator-name = "usb_otg2_vbus";
			regulator-min-microvolt = <5000000>;
			regulator-max-microvolt = <5000000>;
			gpio = <&gpio1 12 0>;
			enable-active-high;
		};
	};

	sound-sgtl5000 {
		compatible = "fsl,imx-audio-sgtl5000";
		cpu-dai = <&ssi1>;
		audio-codec = <&sgtl5000>;
		model = "imx-sgtl5000";
		mux-int-port = <1>;  /* SSI1=1, SSI2=2, SSI3=7 */
		mux-ext-port = <6>;
		audio-routing =
			"LINE_IN", "Line In Jack",
//###			"MIC_IN", "Mic Jack",
//###			"Line Out Jack", "LINE_OUT",
			"Headphone Jack", "HP_OUT";
	};

	/* -------------------- BOARD INFO -------------------- */
	bdinfo {
		compatible = "bdinfo";
		board_name = "efusa9x";
		ecc_strength = "8";
	};
};

&iomuxc {
	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_hog>;

	imx6x-efusa9x {
		pinctrl_hog: hoggrp {
			fsl,pins = <
				/* VLCD_ON */
				MX6SX_PAD_LCD1_DATA18__GPIO3_IO_19	0x17059
				/* I2C2_IRQn (SX8655, ext. touch) */
				MX6SX_PAD_SD3_CLK__GPIO7_IO_0		0x80000000
				/* RESETOUTn */
				MX6SX_PAD_ENET1_CRS__GPIO2_IO_1		0x80000000
#if 0 //###
				MX6SX_PAD_GPIO1_IO13__WDOG1_WDOG_ANY	0x10b0
#endif //###
				/* Reset for external touches on I2C_A */
				MX6SX_PAD_LCD1_DATA20__GPIO3_IO_21	0x80000000
			>;
		};

		pinctrl_audmux_6: audmux-6 {
			fsl,pins = <
				MX6SX_PAD_SD3_DATA0__AUDMUX_AUD6_RXD	0x130b0
				MX6SX_PAD_SD3_DATA1__AUDMUX_AUD6_TXC	0x130b0
				MX6SX_PAD_SD3_DATA2__AUDMUX_AUD6_TXFS	0x130b0
				MX6SX_PAD_SD3_DATA3__AUDMUX_AUD6_TXD	0x130b0
				MX6SX_PAD_ENET1_MDIO__AUDMUX_MCLK	0x130b0 //###???
			>;
		};

		pinctrl_enet1_1: enet1grp-1 {
			fsl,pins = <
				MX6SX_PAD_ENET2_CRS__ENET1_MDIO		0xa0b1
				MX6SX_PAD_ENET2_COL__ENET1_MDC		0xa0b1
				MX6SX_PAD_ENET2_RX_CLK__ENET2_REF_CLK_25M 0xa0b9
				MX6SX_PAD_ENET1_TX_CLK__ENET1_REF_CLK1	0xa0b1
				MX6SX_PAD_RGMII1_TXC__ENET1_RGMII_TXC	0xa0b9
				MX6SX_PAD_RGMII1_TD0__ENET1_TX_DATA_0	0xa0b1
				MX6SX_PAD_RGMII1_TD1__ENET1_TX_DATA_1	0xa0b1
				MX6SX_PAD_RGMII1_TD2__ENET1_TX_DATA_2	0xa0b1
				MX6SX_PAD_RGMII1_TD3__ENET1_TX_DATA_3	0xa0b1
				MX6SX_PAD_RGMII1_TX_CTL__ENET1_TX_EN	0xa0b1
				MX6SX_PAD_RGMII1_RXC__ENET1_RX_CLK	0x3081
				MX6SX_PAD_RGMII1_RD0__ENET1_RX_DATA_0	0x3081
				MX6SX_PAD_RGMII1_RD1__ENET1_RX_DATA_1	0x3081
				MX6SX_PAD_RGMII1_RD2__ENET1_RX_DATA_2	0x3081
				MX6SX_PAD_RGMII1_RD3__ENET1_RX_DATA_3	0x3081
				MX6SX_PAD_RGMII1_RX_CTL__ENET1_RX_EN	0x3081
			>;
		};

		pinctrl_enet2_1: enet2grp-1 {
			fsl,pins = <
				MX6SX_PAD_RGMII2_TXC__ENET2_RGMII_TXC	0xa0b9
				MX6SX_PAD_RGMII2_TD0__ENET2_TX_DATA_0	0xa0b1
				MX6SX_PAD_RGMII2_TD1__ENET2_TX_DATA_1	0xa0b1
				MX6SX_PAD_RGMII2_TD2__ENET2_TX_DATA_2	0xa0b1
				MX6SX_PAD_RGMII2_TD3__ENET2_TX_DATA_3	0xa0b1
				MX6SX_PAD_RGMII2_TX_CTL__ENET2_TX_EN	0xa0b1
				MX6SX_PAD_RGMII2_RXC__ENET2_RX_CLK	0x3081
				MX6SX_PAD_RGMII2_RD0__ENET2_RX_DATA_0	0x3081
				MX6SX_PAD_RGMII2_RD1__ENET2_RX_DATA_1	0x3081
				MX6SX_PAD_RGMII2_RD2__ENET2_RX_DATA_2	0x3081
				MX6SX_PAD_RGMII2_RD3__ENET2_RX_DATA_3	0x3081
				MX6SX_PAD_RGMII2_RX_CTL__ENET2_RX_EN	0x3081
			>;
		};

		pinctrl_lcdif1_1: lcd1grp-1 {
			fsl,pins = <
				MX6SX_PAD_LCD1_CLK__LCDIF1_CLK		0x00b0
				MX6SX_PAD_LCD1_DATA00__LCDIF1_DATA_0	0x00b0
				MX6SX_PAD_LCD1_DATA01__LCDIF1_DATA_1	0x00b0
				MX6SX_PAD_LCD1_DATA02__LCDIF1_DATA_2	0x00b0
				MX6SX_PAD_LCD1_DATA03__LCDIF1_DATA_3	0x00b0
				MX6SX_PAD_LCD1_DATA04__LCDIF1_DATA_4	0x00b0
				MX6SX_PAD_LCD1_DATA05__LCDIF1_DATA_5	0x00b0
				MX6SX_PAD_LCD1_DATA06__LCDIF1_DATA_6	0x00b0
				MX6SX_PAD_LCD1_DATA07__LCDIF1_DATA_7	0x00b0
				MX6SX_PAD_LCD1_DATA08__LCDIF1_DATA_8	0x00b0
				MX6SX_PAD_LCD1_DATA09__LCDIF1_DATA_9	0x00b0
				MX6SX_PAD_LCD1_DATA10__LCDIF1_DATA_10	0x00b0
				MX6SX_PAD_LCD1_DATA11__LCDIF1_DATA_11	0x00b0
				MX6SX_PAD_LCD1_DATA12__LCDIF1_DATA_12	0x00b0
				MX6SX_PAD_LCD1_DATA13__LCDIF1_DATA_13	0x00b0
				MX6SX_PAD_LCD1_DATA14__LCDIF1_DATA_14	0x00b0
				MX6SX_PAD_LCD1_DATA15__LCDIF1_DATA_15	0x00b0
				MX6SX_PAD_LCD1_DATA16__LCDIF1_DATA_16	0x00b0
				MX6SX_PAD_LCD1_DATA17__LCDIF1_DATA_17	0x00b0
				MX6SX_PAD_LCD1_ENABLE__LCDIF1_ENABLE	0x00b0
				MX6SX_PAD_LCD1_HSYNC__LCDIF1_HSYNC	0x00b0
				MX6SX_PAD_LCD1_VSYNC__LCDIF1_VSYNC	0x00b0
			>;
		};

		pinctrl_flexcan1_1: flexcan1grp-1 {
			fsl,pins = <
				MX6SX_PAD_SD3_DATA5__CAN1_TX		0x1b020
				MX6SX_PAD_SD3_DATA7__CAN1_RX		0x1b020
			>;
		};

		pinctrl_flexcan2_1: flexcan2grp-1 {
			fsl,pins = <
				MX6SX_PAD_SD3_DATA6__CAN2_TX		0x1b020
				MX6SX_PAD_SD3_DATA4__CAN2_RX		0x1b020
			>;
		};

		pinctrl_gpmi_nand_1: gpmi-nand-1 {
#if 0
			/* Already configured in NBoot/U-Boot */
			fsl,pins = <
				MX6SX_PAD_NAND_CLE__RAWNAND_CLE		0xb0b1
				MX6SX_PAD_NAND_ALE__RAWNAND_ALE		0xb0b1
				MX6SX_PAD_NAND_WP_B__RAWNAND_WP_B	0xb0b1
				MX6SX_PAD_NAND_READY_B__RAWNAND_READY_B	0xb000
				MX6SX_PAD_NAND_CE0_B__RAWNAND_CE0_B	0xb0b1
				//MX6SX_PAD_NAND_CE1_B__RAWNAND_CE1_B	0xb0b1
				MX6SX_PAD_NAND_RE_B__RAWNAND_RE_B	0xb0b1
				MX6SX_PAD_NAND_WE_B__RAWNAND_WE_B	0xb0b1
				MX6SX_PAD_NAND_DATA00__RAWNAND_DATA00	0xb0b1
				MX6SX_PAD_NAND_DATA01__RAWNAND_DATA01	0xb0b1
				MX6SX_PAD_NAND_DATA02__RAWNAND_DATA02	0xb0b1
				MX6SX_PAD_NAND_DATA03__RAWNAND_DATA03	0xb0b1
				MX6SX_PAD_NAND_DATA04__RAWNAND_DATA04	0xb0b1
				MX6SX_PAD_NAND_DATA05__RAWNAND_DATA05	0xb0b1
				MX6SX_PAD_NAND_DATA06__RAWNAND_DATA06	0xb0b1
				MX6SX_PAD_NAND_DATA07__RAWNAND_DATA07	0xb0b1
			>;
#endif
		};

		/* I2C_C: RTC (PCA8565), LVDS-Connector, SGTL5000 (SKIT),
		   Mini-PCIe (SKIT), Camera (SKIT, 2x) */
		pinctrl_i2c1_1: i2c1grp-1 {
			fsl,pins = <
				MX6SX_PAD_GPIO1_IO01__I2C1_SDA		0x4001b8b1
				MX6SX_PAD_GPIO1_IO00__I2C1_SCL		0x4001b8b1
			>;
		};

		/* I2C_A: RGB-Connector (SKIT -> SX8655, LED-driver PCA9632),
		   Touch Connector (SKIT -> FT5x06, MXT), SX8655 (SKIT),
		   Feature Connector (SKIT) */
		pinctrl_i2c2_1: i2c2grp-1 {
			fsl,pins = <
				MX6SX_PAD_QSPI1B_DATA2__I2C2_SDA	0x4001b8b1
				MX6SX_PAD_QSPI1B_DATA3__I2C2_SCL	0x4001b8b1
			>;
		};

		/* I2C_B: Feature Connector (SKIT) */
		pinctrl_i2c3_1: i2c3grp-1 {
			fsl,pins = <
				MX6SX_PAD_KEY_ROW4__I2C3_SDA		0x4001b8b1
				MX6SX_PAD_KEY_COL4__I2C3_SCL		0x4001b8b1
			>;
		};

		pinctrl_ecspi1: ecspi1grp_1 {
			fsl,pins = <
				MX6SX_PAD_QSPI1A_SCLK__ECSPI1_SCLK	0x100b1
				MX6SX_PAD_QSPI1A_DATA0__ECSPI1_MOSI	0x100b1
				MX6SX_PAD_QSPI1A_DATA1__ECSPI1_MISO	0x100b1
				MX6SX_PAD_QSPI1A_SS0_B__GPIO4_IO_22	0x80000000
#ifndef CONFIG_EFUSA9X_UART_C_RTS
				MX6SX_PAD_KEY_ROW2__GPIO2_IO_17		0x80000000
#endif
			>;
		};

		pinctrl_ecspi5: ecspi5grp_1 {
			fsl,pins = <
				MX6SX_PAD_QSPI1B_SS1_B__ECSPI5_SCLK	0x100b1
				MX6SX_PAD_QSPI1A_DQS__ECSPI5_MOSI	0x100b1
				MX6SX_PAD_QSPI1A_SS1_B__ECSPI5_MISO	0x100b1
				MX6SX_PAD_QSPI1B_DQS__GPIO4_IO_28	0x80000000
				MX6SX_PAD_QSPI1A_DATA2__GPIO4_IO_18	0x80000000
			>;
		};

#if 0 //###
		pinctrl_pwm4_0: pwm4grp-0 {
			fsl,pins = <
				MX6SX_PAD_SD1_DATA1__PWM4_OUT		0x110b0
			>;
		};
#endif //###

		pinctrl_pwm6_0: pwm6grp-0 {
			fsl,pins = <
				MX6SX_PAD_LCD1_DATA22__PWM6_OUT		0x110b0
			>;
		};

		pinctrl_uart1_1: uart1grp-1 {
			fsl,pins = <
				MX6SX_PAD_GPIO1_IO04__UART1_TX		0x1b0b1
				MX6SX_PAD_GPIO1_IO05__UART1_RX		0x1b0b1
			>;
		};

		pinctrl_uart3_1: uart3grp-1 {
			fsl,pins = <
				MX6SX_PAD_QSPI1B_SS0_B__UART3_TX	0x1b0b1
				MX6SX_PAD_QSPI1B_SCLK__UART3_RX		0x1b0b1
				MX6SX_PAD_QSPI1B_DATA1__UART3_CTS_B	0x1b0b1
				MX6SX_PAD_QSPI1B_DATA0__UART3_CTS_B	0x1b0b1
			>;
		};

		/* UART_C: Bluetooth communication; if SPI_B needs a
		   second CS, we can not use RTS here */
		pinctrl_uart5_1: uart5grp-1 {
			fsl,pins = <
				MX6SX_PAD_KEY_ROW3__UART5_RX		0x1b0b1
				MX6SX_PAD_KEY_COL3__UART5_TX		0x1b0b1
#ifdef CONFIG_EFUSA9X_UART_C_RTS
				MX6SX_PAD_KEY_ROW2__UART5_CTS_B		0x1b0b1
				MX6SX_PAD_KEY_COL2__UART5_RTS_B		0x1b0b1
#endif
			>;
		};

		pinctrl_uart6_1: uart6grp-1 {
			fsl,pins = <
				MX6SX_PAD_KEY_ROW1__UART6_RX		0x1b0b1
				MX6SX_PAD_KEY_COL1__UART6_TX		0x1b0b1
			>;
		};

		pinctrl_usbotg1_1: usbotg1grp-1 {
			fsl,pins = <
				MX6SX_PAD_GPIO1_IO09__GPIO1_IO_9	0x80000000
				MX6SX_PAD_GPIO1_IO10__ANATOP_OTG1_ID	0x17059
			>;
		};

		pinctrl_usbotg2_1: usbotg2grp-1 {
			fsl,pins = <
				 MX6SX_PAD_GPIO1_IO12__GPIO1_IO_12	0x80000000
//###				 MX6SX_PAD_GPIO1_IO12__USB_OTG2_PWR	0x80000000
			>;
		};

		/* Micro-SD slot on efus-SKIT, alternatively on-board WLAN */
		pinctrl_usdhc1_1: usdhc1grp-1 {
			fsl,pins = <
				MX6SX_PAD_SD1_CMD__USDHC1_CMD		0x17071
				MX6SX_PAD_SD1_CLK__USDHC1_CLK		0x10071
				MX6SX_PAD_SD1_DATA0__USDHC1_DATA0	0x17071
				MX6SX_PAD_SD1_DATA1__USDHC1_DATA1	0x17071
				MX6SX_PAD_SD1_DATA2__USDHC1_DATA2	0x17071
				MX6SX_PAD_SD1_DATA3__USDHC1_DATA3	0x17071
				MX6SX_PAD_GPIO1_IO02__GPIO1_IO_2	0x80000000 /* CD */
				MX6SX_PAD_GPIO1_IO03__GPIO1_IO_3	0x80000000 /* WP */
			>;
		};

		/* Normal-size SD slot on efus-SKIT */
		pinctrl_usdhc2_1: usdhc2grp-1 {
			fsl,pins = <
				MX6SX_PAD_SD2_CMD__USDHC2_CMD		0x17071
				MX6SX_PAD_SD2_CLK__USDHC2_CLK		0x10071
				MX6SX_PAD_SD2_DATA0__USDHC2_DATA0	0x17071
				MX6SX_PAD_SD2_DATA1__USDHC2_DATA1	0x17071
				MX6SX_PAD_SD2_DATA2__USDHC2_DATA2	0x17071
				MX6SX_PAD_SD2_DATA3__USDHC2_DATA3	0x17071
				MX6SX_PAD_GPIO1_IO06__GPIO1_IO_6	0x80000000 /* CD */
				MX6SX_PAD_GPIO1_IO07__GPIO1_IO_7	0x80000000 /* WP */
			>;
		};

		/* EMMC */
		pinctrl_usdhc4_3: usdhc4grp-3 {
			fsl,pins = <
				MX6SX_PAD_SD4_CMD__USDHC4_CMD		0x17071
				MX6SX_PAD_SD4_CLK__USDHC4_CLK		0x10071
				MX6SX_PAD_SD4_DATA0__USDHC4_DATA0	0x17071
				MX6SX_PAD_SD4_DATA1__USDHC4_DATA1	0x17071
				MX6SX_PAD_SD4_DATA2__USDHC4_DATA2	0x17071
				MX6SX_PAD_SD4_DATA3__USDHC4_DATA3	0x17071
				MX6SX_PAD_SD4_DATA4__USDHC4_DATA4	0x17071
				MX6SX_PAD_SD4_DATA5__USDHC4_DATA5	0x17071
				MX6SX_PAD_SD4_DATA6__USDHC4_DATA6	0x17071
				MX6SX_PAD_SD4_DATA7__USDHC4_DATA7	0x17071
//###				MX6SX_PAD_SD4_RESET_B__USDHC4_RESET_B	0x17071 //???
				MX6SX_PAD_SD4_RESET_B__GPIO6_IO_22	0x80000000 //???
			>;
		};

		pinctrl_csi1: csi1grp-0 {
			fsl,pins = <
				MX6SX_PAD_CSI_MCLK__CSI1_FIELD		0x110b0
				MX6SX_PAD_CSI_PIXCLK__CSI1_PIXCLK	0x110b0
				MX6SX_PAD_CSI_VSYNC__CSI1_VSYNC		0x110b0
//###				MX6SX_PAD_CSI_HSYNC__CSI1_HSYNC		0x110b0
//###				MX6SX_PAD_LCD1_DATA17__CSI1_DATA_0	0x110b0
//###				MX6SX_PAD_LCD1_DATA16__CSI1_DATA_1	0x110b0
				MX6SX_PAD_CSI_DATA00__CSI1_DATA_2	0x110b0
				MX6SX_PAD_CSI_DATA01__CSI1_DATA_3	0x110b0
				MX6SX_PAD_CSI_DATA02__CSI1_DATA_4	0x110b0
				MX6SX_PAD_CSI_DATA03__CSI1_DATA_5	0x110b0
				MX6SX_PAD_CSI_DATA04__CSI1_DATA_6	0x110b0
				MX6SX_PAD_CSI_DATA05__CSI1_DATA_7	0x110b0
				MX6SX_PAD_CSI_DATA06__CSI1_DATA_8	0x110b0
				MX6SX_PAD_CSI_DATA07__CSI1_DATA_9	0x110b0
				MX6SX_PAD_LCD1_RESET__GPIO3_IO_27	0x80000000 //Reset
				MX6SX_PAD_CSI_HSYNC__GPIO1_IO_22	0x80000000 //PWDN
			>;
		};

	};
};

&adc1 {
	vref-supply = <&reg_vref_3v3>;
	num-channels = <2>;
	status = "okay";
};

&adc2 {
	vref-supply = <&reg_vref_3v3>;
	num-channels = <2>;
	status = "okay";
};

&audmux {
	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_audmux_6>;
	status = "okay";
};

&clks {
	assigned-clocks = <&clks IMX6SX_PLL4_BYPASS_SRC>,
			  <&clks IMX6SX_PLL4_BYPASS>,
			  <&clks IMX6SX_CLK_PLL4_POST_DIV>;
	assigned-clock-parents = <&clks IMX6SX_CLK_LVDS2_IN>,
				 <&clks IMX6SX_PLL4_BYPASS_SRC>;
	assigned-clock-rates = <0>, <0>, <24576000>;
};

#if 0
&dcic1 {
	dcic_id = <0>;
	dcic_mux = "dcic-lcdif1";
	status = "okay";
};

&dcic2 {
	dcic_id = <1>;
	dcic_mux = "dcic-lvds";
	status = "okay";
};
#endif

&fec1 {
	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_enet1_1>;
	phy-mode = "rgmii";
//###	phy-handle = <&ethphy1>;
//###	pinctrl-assert-gpios = <&max7322 0 GPIO_ACTIVE_HIGH>;
	fsl,magic-packet;
	status = "okay";

#if 0
	mdio {
		#address-cells = <1>;
		#size-cells = <0>;

		ethphy0: ethernet-phy@4 {
//###			compatible = "ethernet-phy-ieee802.3-c22";
			compatible = "ethernet-phy-ieee802.3-c22";
			reg = <4>;
		};

		ethphy1: ethernet-phy@5 {
			compatible = "ethernet-phy-ieee802.3-c22";
			reg = <5>;
		};
	};
#endif
};

&fec2 {
	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_enet2_1>;
	phy-mode = "rgmii";
//###	phy-handle = <&ethphy0>;
	fsl,magic-packet;
	status = "okay";
};

&flexcan1 {
	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_flexcan1_1>;
//###	trx-en-gpio = <&max7310_b 5 GPIO_ACTIVE_HIGH>;
//###	trx-stby-gpio = <&max7310_b 4 GPIO_ACTIVE_HIGH>;
//###	trx-wakeup-gpio = <&max7310_b 7 GPIO_ACTIVE_HIGH>;
	status = "okay";
};

&flexcan2 {
	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_flexcan2_1>;
//###	trx-en-gpio = <&max7310_b 5 GPIO_ACTIVE_HIGH>;
//###	trx-stby-gpio = <&max7310_b 4 GPIO_ACTIVE_HIGH>;
//###	trx-wakeup-gpio = <&max7310_b 7 GPIO_ACTIVE_HIGH>;
	status = "okay";
};

/* I2C_C */
&i2c1 {
	clock-frequency = <100000>;
	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_i2c1_1>;
	status = "okay";

	sgtl5000: sgtl5000@0a {
		compatible = "fsl,sgtl5000";
		reg = <0x0a>;
		clocks = <&clks IMX6SX_CLK_AUDIO>;
		VDDA-supply = <&reg_sgtl5000_vdda>;
		VDDIO-supply = <&reg_sgtl5000_vddio>;
		VDDD-supply = <&reg_sgtl5000_vddd>;
	};

	rtc8565@51 {
		compatible = "nxp,pcf8565", "nxp,pcf8563";
		reg = <0x51>;
	};

#if 0
	ov5640: ov5640@3c {
		compatible = "ovti,ov5640";
		reg = <0x3c>;
		pinctrl-names = "default";
		pinctrl-0 = <&pinctrl_csi1>;
		clocks = <&clks IMX6SX_CLK_CSI>;
		clock-names = "csi_mclk";
		AVDD-supply = <&vgen3_reg>;  /* 2.8v */
		DVDD-supply = <&vgen2_reg>;  /* 1.5v*/
		pwn-gpios = <&gpio1 22 0>;
		rst-gpios = <&gpio3 27 0>;
		csi_id = <0>;
		mclk = <24000000>;
		mclk_source = <0>;
		port {
			ov5640_ep: endpoint {
				remote-endpoint = <&csi1_ep>;
			};
		};
	};
#endif

#if 1
	ov9665: ov9665@30 {
		compatible = "ovti,ov9665";
		reg = <0x30>;
		pinctrl-names = "default";
		pinctrl-0 = <&pinctrl_csi1>;
		clocks = <&clks IMX6SX_CLK_CSI>;
		clock-names = "csi_mclk";
		DOVDD-supply = <&reg_camera_dovdd>;	/* 1.8v */
		AVDD-supply = <&reg_camera_avdd>;	/* 2.8v */
		DVDD-supply = <&reg_camera_dvdd>;	/* 1.5v */
		pwn-gpios = <&gpio1 22 GPIO_ACTIVE_LOW>;
		rst-gpios = <&gpio3 27 GPIO_ACTIVE_HIGH>;
		csi_id = <0>;
		mclk = <24000000>;
		mclk_source = <0>;
		port {
			ov9665_ep: endpoint {
				remote-endpoint = <&csi1_ep>;
			};
		};
	};
#endif
};

/* I2C_A */
&i2c2 {
	clock-frequency = <100000>;
	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_i2c2_1>;
	status = "okay";

	pca963x: pca9632@60 {
		compatible = "nxp,pca9632";
		reg = <0x60>;
		nxp,totem-pole;
		#address-cells = <1>;
		#size-cells = <0>;
		#pwm-cells = <3>;
		#gpio-cells = <2>;
		led@0 {
			reg = <0>;
			label = "0-PWRCTL";
			type = "GPIO";
		};
		led@1 {
			reg = <1>;
			label = "1-LEDCTRL";
			default-on;
			type = "PWM";
		};
		led@2 {
			reg = <2>;
			label = "2-ROTATE";
			type = "GPIO";
		};
		led@3 {
			reg = <3>;
			label = "3-unused";
			type = "LED";
		};
	};

#ifdef CONFIG_EFUSA9X_CAPTOUCH_MXT224
	mxt224@4a {
		compatible = "atmel,maxtouch";
		reg = <0x4a>;
		interrupt-parent = <&gpio7>;
		interrupts = <0 2>;
		atmel,cfg_name = "mxt224.cfg";
		atmel,reset-gpio = <&gpio3 21 GPIO_ACTIVE_LOW>;
#if 0
		atmel,suspend-mode = <2>;
		vdd = <&reg_atmel_mxt_vdd>;
		avdd = <&reg_atmel_mxt_avdd>;
#endif
	};
#endif

        /* Touch driver Focaltech  */
#if 0
	/* Mainline driver, may only work on EDT displays */
	edt-ft5x06@38 {
		compatible = "edt,edt-ft5306";
		reg = <0x38>;
		threshold = <25>;
		gain = <8>;
		offset = <0>;
		interrupt-parent = <&gpio7>;
		interrupts = <0 IRQ_TYPE_EDGE_FALLING>;
		reset-gpios = <&gpio3 21 GPIO_ACTIVE_LOW>;
	};
#else

#ifdef CONFIG_EFUSA9X_CAPTOUCH_FT5x06
	/* F&S driver V2.0 */
	ft5x06_ts@38 {
		compatible = "FocalTech,ft5306";
		reg = <0x38>;
		threshold = <25>;
		gain = <8>;
		offset = <0>;
		interrupt-parent = <&gpio7>;
		interrupts = <0 IRQ_TYPE_EDGE_FALLING>;
		reset-gpios = <&gpio3 21 GPIO_ACTIVE_LOW>;
	};
#endif

#endif

	/* Touch driver SX8654 */
#ifdef CONFIG_EFUSA9X_4WTOUCH_SX8655_ONBOARD
	sx8654@48 {
		compatible = "semtech,sx8654";
		reg = <0x48>;
		touchrate = <0x30>;
		powdly = <0x06>;
		filt = <0x02>;
		setdly = <0x08>;
		pinctrl-names = "default";
		/*pinctrl-0 = <&pinctrl_touchscreen>;*/
		interrupt-parent = <&gpio7>;
		interrupts = <0 IRQ_TYPE_EDGE_FALLING>;
	};
#endif

#ifdef CONFIG_EFUSA9X_4WTOUCH_SX8655_RGBADAPTER
	sx8654@49 {
		compatible = "semtech,sx8654";
		reg = <0x49>;
		touchrate = <0x30>;
		powdly = <0x06>;
		filt = <0x02>;
		setdly = <0x08>;
		pinctrl-names = "default";
		/*pinctrl-0 = <&pinctrl_touchscreen>;*/
		interrupt-parent = <&gpio7>;
		interrupts = <0 IRQ_TYPE_EDGE_FALLING>;
	};
#endif

#if 0
	egalax_ts@04 {
		compatible = "eeti,egalax_ts";
		reg = <0x04>;
		interrupt-parent = <&gpio6>;
		interrupts = <22 2>;
		wakeup-gpios = <&gpio6 22 0>;
	};
#endif
};

/* I2C_B */
&i2c3 {
	clock-frequency = <100000>;
	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_i2c3_1>;
	status = "okay";

	// ### TODO: FT5x06 on I2C_B
	// ### TODO: mXT224 on I2C_B
};


&ssi1 {
//###	fsl,mode = "i2s-master";
	fsl,mode = "i2s-slave";
	status = "okay";
};

&lcdif1 {
	display = <&display0>;			/* Remove when already active */
	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_lcdif1_1>;	/* Remove when already active */
	lcd-supply = <&reg_disp_3v3>;
	status = "okay";

	display0: display {
		bits-per-pixel = <16>;
		bus-width = <18>;
		display-timings {
			native-mode = <&timing0>;
			timing0: wvga {
				clock-frequency = <27000000>;
				hactive = <640>;
				vactive = <480>;
				hfront-porch = <16>;
				hback-porch = <134>;
				hsync-len = <10>;
				vback-porch = <11>;
				vfront-porch = <32>;
				vsync-len = <2>;
				hsync-active = <0>;
				vsync-active = <0>;
				de-active = <1>;
				pixelclk-active = <0>;
			};
		};
	};
};

&lcdif2 {
	display = <&display1>;
	disp-dev = "ldb";
	lcd-supply = <&reg_disp_3v3>;
	status = "okay";

	display1: display {
		bits-per-pixel = <16>;
		bus-width = <18>;
		display-timings {
			native-mode = <&timing1_copy>;
			timing1_copy: wvga {
				clock-frequency = <33500000>;
				hactive = <800>;
				vactive = <480>;
				hfront-porch = <40>;
				hback-porch = <88>;
				hsync-len = <128>;
				vback-porch = <33>;
				vfront-porch = <10>;
				vsync-len = <2>;
				hsync-active = <0>;
				vsync-active = <0>;
				de-active = <1>;
				pixelclk-active = <0>;
			};
		};
	};
};

&ldb {
	status = "okay";

	lvds-channel@0 {
		fsl,data-mapping = "spwg";
		fsl,data-width = <18>;
		crtc = "lcdif2";
		status = "okay";

		display-timings {
			native-mode = <&timing1>;
			timing1: wvga {
				clock-frequency = <33500000>;
				hactive = <800>;
				vactive = <480>;
				hfront-porch = <40>;
				hback-porch = <88>;
				hsync-len = <128>;
				vback-porch = <33>;
				vfront-porch = <10>;
				vsync-len = <2>;
				hsync-active = <0>;
				vsync-active = <0>;
				de-active = <1>;
				pixelclk-active = <0>;
			};
		};
	};
};

#if 0 //###
&pcie {
	reset-gpio = <&max7310_b 3 0>;
	status = "okay";
};
#endif //###

&uart1 {
	/* UART_A: TXD, RXD only, RS232-level on SKIT */
	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_uart1_1>;
	status = "okay";
};

&uart3 {
	/* UART_B: TXD, RXD, RTS, CTS, RS232-level on SKIT */
	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_uart3_1>;
	fsl,uart-has-rtscts;
	status = "okay";
};

&uart5 {
	/* UART_C: Bluetooth communication; if no RTS is needed, we
	   can have a second CS on SPI_B, RS485-level on SKIT */
	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_uart5_1>;
#ifdef CONFIG_EFUSA9X_UART_C_RTS
	fsl,uart-has-rtscts;
#endif
	status = "okay";
};

&uart6 {
	/* UART_D: TXD, RXD only, TTL-level on SKIT feature connector */
	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_uart6_1>;
	status = "okay";
};

&usbotg1 {
	vbus-supply = <&reg_usb_otg1_vbus>;
	dr_mode = "peripheral";
	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_usbotg1_1>;
	status = "okay";
};

&usbotg2 {
	vbus-supply = <&reg_usb_otg2_vbus>;
	dr_mode = "host";
	pinctrl-0 = <&pinctrl_usbotg2_1>;
	status = "okay";
};

&usdhc1 {
	/* External Micro-SD slot on efus SKIT, or on-board WLAN/BT */
	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_usdhc1_1>;
	bus-width = <4>;
#ifdef CONFIG_EFUSA9X_WLAN
	non-removable;
#else
	cd-gpios = <&gpio1 2 0>;
	wp-gpios = <&gpio1 3 0>;
#endif
	keep-power-in-suspend;
	enable-sdio-wakeup;
	status = "okay";
};

&usdhc2 {
	/* External normal sized SD clot on efus SKIT */
	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_usdhc2_1>;
	bus-width = <4>;
	cd-gpios = <&gpio1 6 0>;
	wp-gpios = <&gpio1 7 0>;
	keep-power-in-suspend;
	enable-sdio-wakeup;
	status = "okay";
};

#if 0
&usdhc4 {
	/* On-board EMMC */
	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_usdhc4_3>;
	bus-width = <8>;
	//###cd-gpios = <&gpio7 11 0>;
	no-1-8-v;
	non-removable;
//###	keep-power-in-suspend;
//###	enable-sdio-wakup;
	status = "okay";
};
#endif

#if 0 //###
&pwm4 {
	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_pwm4_0>;
	status = "okay";
};
#endif //###

&pwm6 {
	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_pwm6_0>;
	status = "okay";
};

&pxp {
	status = "okay";
};

&csi1 {
	status = "okay";

	port {
		csi1_ep: endpoint {
			remote-endpoint = <&ov9665_ep>;
		};
	};
};

&csi2 {
	status = "okay";
	port {
		csi2_ep: endpoint {
			remote-endpoint = <&vadc_ep>;
		};
	};
};

/* SPI_A */
&ecspi5 {
	/* SPI_A: 2x CS */
	fsl,spi-num-chipselects = <2>;
	cs-gpios = <&gpio4 28 0>, <&gpio4 18 0>;
	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_ecspi5>;
	status = "okay";

	spidev@0 {
		#address-cells = <1>;
		#size-cells = <1>;
		compatible = "linux,spidev";
		spi-max-frequency = <20000000>;
		reg = <0>;
	};

	spidev@1 {
		#address-cells = <1>;
		#size-cells = <1>;
		compatible = "linux,spidev";
		spi-max-frequency = <20000000>;
		reg = <1>;
	};
};

&ecspi1 {
	/* SPI_B, 1x or 2x CS, depending on UART_C */
#ifdef CONFIG_EFUSA9X_UART_C_RTS
	/* If UART_C uses TS, we have only one CS for SPI_B */
	fsl,spi-num-chipselects = <1>;
	cs-gpios = <&gpio4 22 0>;
#else
	/* If UART_C does not use RTS, we can have a second CS on SPI_B */
	fsl,spi-num-chipselects = <2>;
	cs-gpios = <&gpio4 22 0>, <&gpio2 17 0>;
#endif
	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_ecspi1>;
	status = "okay";

	spidev@0 {
		#address-cells = <1>;
		#size-cells = <1>;
		compatible = "linux,spidev";
		spi-max-frequency = <20000000>;
		reg = <0>;
	};

#ifndef CONFIG_EFUSA9X_UART_C_RTS
	spidev@3 {
		#address-cells = <1>;
		#size-cells = <1>;
		compatible = "linux,spidev";
		spi-max-frequency = <20000000>;
		reg = <3>;
	};
#endif
};

&dma_apbh {
	/* Switch to F&S implementation of APBH DMA driver for GPMI (NAND) */
	compatible = "fus,imx6sx-dma-apbh", "fus,imx28-dma-apbh";
};

&gpmi {
	/* Switch to F&S implementation of GPMI NAND driver */
	compatible = "fus,imx6sx-gpmi-nand";
	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_gpmi_nand_1>;
	fus,skipblocks = <2>;
	fus,chunk1k;
//###	fus,ecc_strength = <8>;		// Spare area 64 bytes
	fus,ecc_strength = <52>;	// Spare area 224 bytes
	status = "okay";
};

&vadc {
	vadc_in = <0>;
	csi_id = <1>;
	status = "okay";
	port {
		vadc_ep: endpoint {
			remote-endpoint = <&csi2_ep>;
		};
	};
};
