/*
 * Copyright 2016-2017 F&S Elektronik Systeme GmbH
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 */

#include <dt-bindings/pwm/pwm.h>
#include <fsversion.h>

/*
 * When using one IPU, having LCD and LVDS0 at the same time is not possible,
 * because both devices would need to use display 0. But this can be simulated
 * by using LVDS1 instead of LVDS0 and activating Dual Mode.
 */
#ifdef CONFIG_NETDCUA9_USE_ONE_IPU
#undef CONFIG_NETDCUA9_MXCFB2
#undef CONFIG_NETDCUA9_MXCFB3

#if (((CONFIG_NETDCUA9_MXCFB0 == DISPLAY_LCD) \
      || (CONFIG_NETDCUA9_MXCFB0 == DISPLAY_BT656)) \
     && (CONFIG_NETDCUA9_MXCFB1 == DISPLAY_LVDS0))
#undef CONFIG_NETDCUA9_MXCFB1
#define CONFIG_NETDCUA9_MXCFB1		DISPLAY_LVDS1
#define __MOVE_LVDS0_TO_LVDS1_DUAL_MODE__
#endif

#if ((CONFIG_NETDCUA9_MXCFB0 == DISPLAY_LVDS0) \
     && ((CONFIG_NETDCUA9_MXCFB1 == DISPLAY_LCD) \
         || (CONFIG_NETDCUA9_MXCFB1) == DISPLAY_BT656))
#undef CONFIG_NETDCUA9_MXCFB0
#define CONFIG_NETDCUA9_MXCFB0		DISPLAY_LVDS1
#define __MOVE_LVDS0_TO_LVDS1_DUAL_MODE__
#endif

#ifdef __MOVE_LVDS0_TO_LVDS1_DUAL_MODE__
#undef CONFIG_NETDCUA9_LVDS1_MAPPING
#undef CONFIG_NETDCUA9_LVDS1_BPP
#undef CONFIG_NETDCUA9_LVDS1_PIX_FMT
#undef CONFIG_NETDCUA9_LVDS1_DATA_WIDTH
#undef CONFIG_NETDCUA9_LVDS1_TIMING
#define CONFIG_NETDCUA9_LVDS1_MAPPING	CONFIG_NETDCUA9_LVDS0_MAPPING
#define CONFIG_NETDCUA9_LVDS1_BPP	CONFIG_NETDCUA9_LVDS0_BPP
#define CONFIG_NETDCUA9_LVDS1_PIX_FMT	CONFIG_NETDCUA9_LVDS0_PIX_FMT
#define CONFIG_NETDCUA9_LVDS1_DATA_WIDTH CONFIG_NETDCUA9_LVDS0_DATA_WIDTH
#define CONFIG_NETDCUA9_LVDS1_TIMING	CONFIG_NETDCUA9_LVDS0_TIMING
#ifndef CONFIG_NETDCUA9_LVDS_DUAL_MODE
#define CONFIG_NETDCUA9_LVDS_DUAL_MODE
#endif
#endif
#endif /* CONFIG_NETDCUA9_USE_ONE_IPU */

/* Do we have LCD? */
#if ((CONFIG_NETDCUA9_MXCFB0 == DISPLAY_LCD) \
    || (CONFIG_NETDCUA9_MXCFB1 == DISPLAY_LCD) \
    || (CONFIG_NETDCUA9_MXCFB2 == DISPLAY_LCD) \
    || (CONFIG_NETDCUA9_MXCFB3 == DISPLAY_LCD))
#define CONFIG_NETDCUA9_LCD
#if ((CONFIG_NETDCUA9_MXCFB0 == DISPLAY_LCD) \
    || (CONFIG_NETDCUA9_MXCFB1 == DISPLAY_LCD))
#define __LCD_ON_0_OR_1__	1
#define __LCD_ON_2_OR_3__	0
#else
#define __LCD_ON_0_OR_1__	0
#define __LCD_ON_2_OR_3__	1
#endif
#endif

/* Do we have BT656? */
#if ((CONFIG_NETDCUA9_MXCFB0 == DISPLAY_BT656) \
    || (CONFIG_NETDCUA9_MXCFB1 == DISPLAY_BT656) \
    || (CONFIG_NETDCUA9_MXCFB2 == DISPLAY_BT656) \
    || (CONFIG_NETDCUA9_MXCFB3 == DISPLAY_BT656))
#define CONFIG_NETDCUA9_BT656
#if ((CONFIG_NETDCUA9_MXCFB0 == DISPLAY_BT656) \
    || (CONFIG_NETDCUA9_MXCFB1 == DISPLAY_BT656))
#define __BT656_ON_0_OR_1__	1
#define __BT656_ON_2_OR_3__	0
#else
#define __BT656_ON_0_OR_1__	0
#define __BT656_ON_2_OR_3__	1
#endif
#endif

/* Do we have HDMI? */
#if ((CONFIG_NETDCUA9_MXCFB0 == DISPLAY_HDMI) \
    || (CONFIG_NETDCUA9_MXCFB1 == DISPLAY_HDMI) \
    || (CONFIG_NETDCUA9_MXCFB2 == DISPLAY_HDMI) \
    || (CONFIG_NETDCUA9_MXCFB3 == DISPLAY_HDMI))
#define CONFIG_NETDCUA9_HDMI
#define CONFIG_NETDCUA9_HDMI_AUDIO
#define CONFIG_NETDCUA9_HDMI_CEC
#if ((CONFIG_NETDCUA9_MXCFB0 == DISPLAY_HDMI) \
    || (CONFIG_NETDCUA9_MXCFB1 == DISPLAY_HDMI))
#define __HDMI_ON_0_OR_1__	1
#define __HDMI_ON_2_OR_3__	0
#else
#define __HDMI_ON_0_OR_1__	0
#define __HDMI_ON_2_OR_3__	1
#endif
#endif

/* Do we have LVDS0? */
#if ((CONFIG_NETDCUA9_MXCFB0 == DISPLAY_LVDS0) \
    || (CONFIG_NETDCUA9_MXCFB1 == DISPLAY_LVDS0) \
    || (CONFIG_NETDCUA9_MXCFB2 == DISPLAY_LVDS0) \
    || (CONFIG_NETDCUA9_MXCFB3 == DISPLAY_LVDS0))
#define CONFIG_NETDCUA9_LVDS0
#if ((CONFIG_NETDCUA9_MXCFB0 == DISPLAY_LVDS0) \
    || (CONFIG_NETDCUA9_MXCFB1 == DISPLAY_LVDS0))
#define __LVDS0_ON_0_OR_1__	1
#define __LVDS0_ON_2_OR_3__	0
#else
#define __LVDS0_ON_0_OR_1__	0
#define __LVDS0_ON_2_OR_3__	1
#endif
#endif

/* Do we have LVDS1? */
#if ((CONFIG_NETDCUA9_MXCFB0 == DISPLAY_LVDS1) \
    || (CONFIG_NETDCUA9_MXCFB1 == DISPLAY_LVDS1) \
    || (CONFIG_NETDCUA9_MXCFB2 == DISPLAY_LVDS1) \
    || (CONFIG_NETDCUA9_MXCFB3 == DISPLAY_LVDS1))
#define CONFIG_NETDCUA9_LVDS1
#if ((CONFIG_NETDCUA9_MXCFB0 == DISPLAY_LVDS1) \
    || (CONFIG_NETDCUA9_MXCFB1 == DISPLAY_LVDS1))
#define __LVDS1_ON_0_OR_1__	1
#define __LVDS1_ON_2_OR_3__	0
#else
#define __LVDS1_ON_0_OR_1__	0
#define __LVDS1_ON_2_OR_3__	1
#endif
#endif

/* Check which LVDS will be the primary display */
#if (CONFIG_NETDCUA9_MXCFB0 == DISPLAY_LVDS0)
#define __LVDS0_PRIMARY__
#elif (CONFIG_NETDCUA9_MXCFB0 == DISPLAY_LVDS1)
#define __LVDS1_PRIMARY__
#elif (CONFIG_NETDCUA9_MXCFB1 == DISPLAY_LVDS0)
#define __LVDS0_PRIMARY__
#elif (CONFIG_NETDCUA9_MXCFB1 == DISPLAY_LVDS1)
#define __LVDS1_PRIMARY__
#elif (CONFIG_NETDCUA9_MXCFB2 == DISPLAY_LVDS0)
#define __LVDS0_PRIMARY__
#elif (CONFIG_NETDCUA9_MXCFB2 == DISPLAY_LVDS1)
#define __LVDS1_PRIMARY__
#elif (CONFIG_NETDCUA9_MXCFB3 == DISPLAY_LVDS0)
#define __LVDS0_PRIMARY__
#elif (CONFIG_NETDCUA9_MXCFB3 == DISPLAY_LVDS1)
#define __LVDS1_PRIMARY__
#endif

/ {
	aliases {
		mxcfb0 = &mxcfb0;
		mxcfb1 = &mxcfb1;
		mxcfb2 = &mxcfb2;
		mxcfb3 = &mxcfb3;
		ethernet1 = &ax88796;
		nand = &gpmi;
	};

	memory {
		reg = <0x10000000 0x40000000>;
	};

	regulators {
		compatible = "simple-bus";
		#address-cells = <1>;
		#size-cells = <0>;

		reg_vref_3v3: regulator_3v3 {
			compatible = "regulator-fixed";
			regulator-name = "vref-3V3";
			regulator-min-microvolt = <3300000>;
			regulator-max-microvolt = <3300000>;
			regulator-always-on;
		};

#ifdef CONFIG_NETDCUA9_OTG_HOST
		/* USB_OTG_PWR only available as GPIO, use regulator */
		reg_usb_otg_vbus: usb_otg_vbus {
			compatible = "regulator-fixed";
			regulator-name = "usb_otg_vbus";
			regulator-min-microvolt = <5000000>;
			regulator-max-microvolt = <5000000>;
			gpio = <&gpio1 9 0>;
			enable-active-high;
		};
#endif

		/* USB_H1_PWR handled by USB controller, no regulator needed */
#if 0 //###
		reg_usb_h1_vbus: usb_h1_vbus {
			compatible = "regulator-fixed";
			regulator-name = "usb_h1_vbus";
			regulator-min-microvolt = <5000000>;
			regulator-max-microvolt = <5000000>;
			gpio = <&gpio1 0 0>;
			enable-active-high;
		};
#endif //###

		reg_ldb_bl: backlight_ldb {
			compatible = "regulator-fixed";
			regulator-name = "ldb-bl";
			gpio = <&gpio2 8 GPIO_ACTIVE_HIGH>;
			regulator-min-microvolt = <3300000>;
			regulator-max-microvolt = <3300000>;
			enable-active-high;
		};

		/* LCD power on voltage */
		reg_vlcd: vlcd {
			compatible = "regulator-fixed";
			regulator-name = "VLCD";
			gpio = <&gpio2 11 GPIO_ACTIVE_HIGH>;
			regulator-min-microvolt = <3300000>;
			regulator-max-microvolt = <3300000>;
			enable-active-high;
		};

#ifdef CONFIG_NETDCUA9_5V_LVDS
		/* Switching LVDS power from 3.3V to 5V is available since
		   board rev. 1.21; on earlier board revisions, this GPIO is
		   not connected and has no effect */
		reg_vlcd_5V: vlcd-5V {
			compatible = "regulator-fixed";
			regulator-name = "VLCD-5V";
			gpio = <&gpio1 4 GPIO_ACTIVE_HIGH>;
		};
#endif
		/* CAN */
		reg_can: regulator_can {
			compatible = "regulator-fixed";
			regulator-name = "can";
		};
#ifdef CONFIG_NETDCUA9_UART_B_RS485
		reg_rs485: regulator_rs485 {
			compatible = "regulator-fixed";
			regulator-name = "rs485";
			gpio = <&gpio3 9 GPIO_ACTIVE_HIGH>;
			regulator-min-microvolt = <3300000>;
			regulator-max-microvolt = <3300000>;
		};
#endif

#ifdef CONFIG_NETDCUA9_EMMC
		/* eMMC */
		reg_sd3_vmmc: sd3_vmmc{
			compatible = "regulator-fixed";
			regulator-name = "P3V3_SDc_SWITCHED";
			regulator-min-microvolt = <3300000>;
			regulator-max-microvolt = <3300000>;
			regulator-always-on;
		};
#endif

#if 0 //### todo
#ifdef CONFIG_NETDCUA9_PARALLEL_CAMERA
		reg_camera_dovdd: camera_dovdd {
			compatible = "regulator-fixed";
			regulator-name = "DOVDD-supply";
			regulator-min-microvolt = <1800000>;
			regulator-max-microvolt = <1800000>;
		};

		reg_camera_avdd: camera_avdd {
			compatible = "regulator-fixed";
			regulator-name = "VAVDD-supply";
			regulator-min-microvolt = <2800000>;
			regulator-max-microvolt = <2800000>;
		};

		reg_camera_dvdd: camera_dvdd {
			compatible = "regulator-fixed";
			regulator-name = "DVDD-supply";
			regulator-min-microvolt = <1500000>;
			regulator-max-microvolt = <1500000>;
		};
#endif /* CONFIG_NETDCUA9_PARALLEL_CAMERA */
#endif
	};

	/* F&S board information */
	bdinfo: bdinfo {
		compatible = "bdinfo";
		board_name = "netdcua9";
		ecc_strength = "8";
		dts_version = FS_LINUX_VERSION;
	};

#ifdef CONFIG_NETDCUA9_WM9715_AUDIO
	sound {
		compatible = "fus,imx-audio-wm9715";
		fus,model = "F&S Audio WM9715";
		audio-cpu = <&ssi1>;
		clocks = <&clks IMX6QDL_CLK_CKO>;
		mux-int-port = <1>;  /* SSI1=1, SSI2=2, SSI3=7 */
		mux-ext-port = <4>;
	};
#endif

	mxcfb0: fb@0 {
		compatible = "fsl,mxc_sdc_fb";
		late_init = <0>;
#if (CONFIG_NETDCUA9_MXCFB0 == DISPLAY_LCD)
		disp_dev = "lcd";
		default_bpp = <CONFIG_NETDCUA9_LCD_BPP>;
		interface_pix_fmt = CONFIG_NETDCUA9_LCD_PIX_FMT;
		int_clk = <1>;
		mode_str = CONFIG_NETDCUA9_LCD_MODE_STR;
#elif (CONFIG_NETDCUA9_MXCFB0 == DISPLAY_BT656)
		disp_dev = "bt656";
		default_bpp = <CONFIG_NETDCUA9_BT656_BPP>;
		interface_pix_fmt = CONFIG_NETDCUA9_BT656_PIX_FMT;
		int_clk = <0>;
		mode_str = CONFIG_NETDCUA9_BT656_MODE_STR;
		clock-frequency = <27000000>;
#elif (CONFIG_NETDCUA9_MXCFB0 == DISPLAY_HDMI)
		disp_dev = "hdmi";
		default_bpp = <CONFIG_NETDCUA9_HDMI_BPP>;
		interface_pix_fmt = CONFIG_NETDCUA9_HDMI_PIX_FMT;
		int_clk = <0>;
		mode_str = CONFIG_NETDCUA9_HDMI_MODE_STR;
#elif (CONFIG_NETDCUA9_MXCFB0 == DISPLAY_LVDS0)
		disp_dev = "ldb";
		default_bpp = <CONFIG_NETDCUA9_LVDS0_BPP>;
		interface_pix_fmt = CONFIG_NETDCUA9_LVDS0_PIX_FMT;
		int_clk = <1>;
#elif (CONFIG_NETDCUA9_MXCFB0 == DISPLAY_LVDS1)
		disp_dev = "ldb";
		default_bpp = <CONFIG_NETDCUA9_LVDS1_BPP>;
		interface_pix_fmt = CONFIG_NETDCUA9_LVDS1_PIX_FMT;
		int_clk = <1>;
#else
		status = "disabled";
#endif
	};

	mxcfb1: fb@1 {
		compatible = "fsl,mxc_sdc_fb";
		late_init = <0>;
#if (CONFIG_NETDCUA9_MXCFB1 == DISPLAY_LCD)
		disp_dev = "lcd";
		default_bpp = <CONFIG_NETDCUA9_LCD_BPP>;
		interface_pix_fmt = CONFIG_NETDCUA9_LCD_PIX_FMT;
		int_clk = <1>;
		mode_str = CONFIG_NETDCUA9_LCD_MODE_STR;
#elif (CONFIG_NETDCUA9_MXCFB1 == DISPLAY_BT656)
		disp_dev = "bt656";
		default_bpp = <CONFIG_NETDCUA9_BT656_BPP>;
		interface_pix_fmt = CONFIG_NETDCUA9_BT656_PIX_FMT;
		int_clk = <0>;
		mode_str = CONFIG_NETDCUA9_BT656_MODE_STR;
		clock-frequency = <27000000>;
#elif (CONFIG_NETDCUA9_MXCFB1 == DISPLAY_HDMI)
		disp_dev = "hdmi";
		default_bpp = <CONFIG_NETDCUA9_HDMI_BPP>;
		interface_pix_fmt = CONFIG_NETDCUA9_HDMI_PIX_FMT;
		int_clk = <0>;
		mode_str = CONFIG_NETDCUA9_HDMI_MODE_STR;
#elif (CONFIG_NETDCUA9_MXCFB1 == DISPLAY_LVDS0)
		disp_dev = "ldb";
		default_bpp = <CONFIG_NETDCUA9_LVDS0_BPP>;
		interface_pix_fmt = CONFIG_NETDCUA9_LVDS0_PIX_FMT;
		int_clk = <1>;
#elif (CONFIG_NETDCUA9_MXCFB1 == DISPLAY_LVDS1)
		disp_dev = "ldb";
		default_bpp = <CONFIG_NETDCUA9_LVDS1_BPP>;
		interface_pix_fmt = CONFIG_NETDCUA9_LVDS1_PIX_FMT;
		int_clk = <1>;
#else
		status = "disabled";
#endif
	};

	mxcfb2: fb@2 {
		compatible = "fsl,mxc_sdc_fb";
		late_init = <0>;
#if (CONFIG_NETDCUA9_MXCFB2 == DISPLAY_LCD)
		disp_dev = "lcd";
		default_bpp = <CONFIG_NETDCUA9_LCD_BPP>;
		interface_pix_fmt = CONFIG_NETDCUA9_LCD_PIX_FMT;
		int_clk = <1>;
		mode_str = CONFIG_NETDCUA9_LCD_MODE_STR;
#elif (CONFIG_NETDCUA9_MXCFB2 == DISPLAY_BT656)
		disp_dev = "bt656";
		default_bpp = <CONFIG_NETDCUA9_BT656_BPP>;
		interface_pix_fmt = CONFIG_NETDCUA9_BT656_PIX_FMT;
		int_clk = <0>;
		mode_str = CONFIG_NETDCUA9_BT656_MODE_STR;
		clock-frequency = <27000000>;
#elif (CONFIG_NETDCUA9_MXCFB2 == DISPLAY_HDMI)
		disp_dev = "hdmi";
		default_bpp = <CONFIG_NETDCUA9_HDMI_BPP>;
		interface_pix_fmt = CONFIG_NETDCUA9_HDMI_PIX_FMT;
		int_clk = <0>;
		mode_str = CONFIG_NETDCUA9_HDMI_MODE_STR;
#elif (CONFIG_NETDCUA9_MXCFB2 == DISPLAY_LVDS0)
		disp_dev = "ldb";
		default_bpp = <CONFIG_NETDCUA9_LVDS0_BPP>;
		interface_pix_fmt = CONFIG_NETDCUA9_LVDS0_PIX_FMT;
		int_clk = <1>;
#elif (CONFIG_NETDCUA9_MXCFB2 == DISPLAY_LVDS1)
		disp_dev = "ldb";
		default_bpp = <CONFIG_NETDCUA9_LVDS1_BPP>;
		interface_pix_fmt = CONFIG_NETDCUA9_LVDS1_PIX_FMT;
		int_clk = <1>;
#else
		status = "disabled";
#endif
	};

	mxcfb3: fb@3 {
		compatible = "fsl,mxc_sdc_fb";
		late_init = <0>;
#if (CONFIG_NETDCUA9_MXCFB3 == DISPLAY_LCD)
		disp_dev = "lcd";
		default_bpp = <CONFIG_NETDCUA9_LCD_BPP>;
		interface_pix_fmt = CONFIG_NETDCUA9_LCD_PIX_FMT;
		int_clk = <1>;
		mode_str = CONFIG_NETDCUA9_LCD_MODE_STR;
#elif (CONFIG_NETDCUA9_MXCFB3 == DISPLAY_BT656)
		disp_dev = "bt656";
		default_bpp = <CONFIG_NETDCUA9_BT656_BPP>;
		interface_pix_fmt = CONFIG_NETDCUA9_BT656_PIX_FMT;
		int_clk = <0>;
		mode_str = CONFIG_NETDCUA9_BT656_MODE_STR;
		clock-frequency = <27000000>;
#elif (CONFIG_NETDCUA9_MXCFB3 == DISPLAY_HDMI)
		disp_dev = "hdmi";
		default_bpp = <CONFIG_NETDCUA9_HDMI_BPP>;
		interface_pix_fmt = CONFIG_NETDCUA9_HDMI_PIX_FMT;
		int_clk = <0>;
		mode_str = CONFIG_NETDCUA9_HDMI_MODE_STR;
#elif (CONFIG_NETDCUA9_MXCFB3 == DISPLAY_LVDS0)
		disp_dev = "ldb";
		default_bpp = <CONFIG_NETDCUA9_LVDS0_BPP>;
		interface_pix_fmt = CONFIG_NETDCUA9_LVDS0_PIX_FMT;
		int_clk = <1>;
#elif (CONFIG_NETDCUA9_MXCFB3 == DISPLAY_LVDS1)
		disp_dev = "ldb";
		default_bpp = <CONFIG_NETDCUA9_LVDS1_BPP>;
		interface_pix_fmt = CONFIG_NETDCUA9_LVDS1_PIX_FMT;
		int_clk = <1>;
#else
		status = "disabled";
#endif
	};

#ifdef CONFIG_NETDCUA9_LCD
	lcd: lcd@0 {
		compatible = "fsl,lcd";
		lcd-supply = <&reg_vlcd>;
		pinctrl-names = "default";
		pinctrl-0 = <&pinctrl_ipu1_ctrl &pinctrl_ipu1_dat>;
		status = "disabled";
	};
#endif

#ifdef CONFIG_NETDCUA9_BT656
	bt656: bt656@0 {
		compatible = "fsl,bt656";
		default_ifmt = "BT656";
		pinctrl-names = "default";
		pinctrl-0 = <&pinctrl_ipu1_bt656>;
		status = "disabled";
	};
#endif

	/* LCD/LVDS backlight PWM on backlight connector */
	backlight_lcd_ldb {
		compatible = "pwm-backlight";
/* We have one PWM for both backlights, but with the LVDS Display we need PWM
 * inverted and with the LCD Display we need PWM normal. So we have to do a
 * differentiation
 */
#ifdef CONFIG_NETDCUA9_LCD
		pwms = <&pwm3 0 5000000 PWM_POLARITY_INVERTED>;
#else
#ifndef DISPLAY_LVDS_CHIMEI
		pwms = <&pwm3 0 250000 PWM_POLARITY_INVERTED>;
#else
		pwms = <&pwm3 0 5000000 0>;
#endif
#endif
		power-supply = <&reg_ldb_bl>;
#if !defined(DISPLAY_LVDS_CHIMEI) && !defined(CONFIG_NETDCUA9_LCD)
		brightness-levels = <135 143 151 159 167 175 183 191
				     199 207 215 223 231 239 247 255>;
#else
		brightness-levels = <0 1 5 10 18 28 41 56
				     73 92 113 137 163 192 222 255>;
#endif
		default-brightness-level = <14>;
		fb-names = "lcd", "ldb0", "ldb1";
	};

#if 0 //### todo
#ifdef CONFIG_NETDCUA9_PARALLEL_CAMERA
	/* Parallel digital camera interface */
	v4l2_cap_0 {
		compatible = "fsl,imx6q-v4l2-capture";
		ipu_id = <0>;
		csi_id = <0>;
		mclk_source = <0>;
		status = "okay";
	};
#endif
	v4l2_out {
		compatible = "fsl,mxc_v4l2_output";
		status = "okay";
	};
#endif
	leds {
		compatible = "gpio-leds";
		pinctrl-names = "default";
		pinctrl-0 = <&pinctrl_status_leds>;

		status_1 {
			label = "Status1";
			gpios = <&gpio7 13 GPIO_ACTIVE_HIGH>;
			default-state = "keep";
		};

		status_2 {
			label = "Status2";
			gpios = <&gpio7 12 GPIO_ACTIVE_HIGH>;
			default-state = "keep";
		};
	};
};

/* RAM size for Continuous Memory Allocator; if not defined, use 320 MB */
#ifndef CONFIG_NETDCUA9_CMA_SIZE
#define CONFIG_NETDCUA9_CMA_SIZE 0x14000000
#endif
&cma {
	size = <CONFIG_NETDCUA9_CMA_SIZE>;
};

&busfreq {
	/* Disable bus frequency scaling, because reducing bus frequency to
	   24 MHz does not work with all types of DDR3 RAM */
	disable-scaling;
};

&clks {
	assigned-clocks =
#ifdef CONFIG_NETDCUA9_LVDS0_CLK
			  <&clks IMX6QDL_CLK_LDB_DI0_SEL>,
#endif
#ifdef CONFIG_NETDCUA9_LVDS1_CLK
			  <&clks IMX6QDL_CLK_LDB_DI1_SEL>,
#endif
			  <&clks IMX6QDL_CLK_PLL4_AUDIO_DIV>,
			  <&clks IMX6QDL_CLK_CKO1_SEL>,
			  <&clks IMX6QDL_CLK_CKO1_PODF>,
			  <&clks IMX6QDL_CLK_CKO>;

	assigned-clock-parents =
#ifdef CONFIG_NETDCUA9_LVDS0_CLK
				 <&clks CONFIG_NETDCUA9_LVDS0_CLK>,
#endif
#ifdef CONFIG_NETDCUA9_LVDS1_CLK
				 <&clks CONFIG_NETDCUA9_LVDS1_CLK>,
#endif
			         <0>,
				 <&clks IMX6QDL_CLK_PLL4_AUDIO_DIV>,
				 <0>,
				 <&clks IMX6QDL_CLK_CKO1>;

	assigned-clock-rates =
#ifdef CONFIG_NETDCUA9_LVDS0_CLK
				<0>,
#endif
#ifdef CONFIG_NETDCUA9_LVDS1_CLK
				<0>,
#endif
				<196608000>,
				<196608000>,
				<24576000>;
};

#ifdef CONFIG_NETDCUA9_SPI_A
/* SPI_A (1x CS) */
&ecspi1 {
	fsl,spi-num-chipselects = <1>;
	cs-gpios = <&gpio5 25 0>;	/* SPI_A_CS0 */

	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_ecspi1_1 &pinctrl_ecspi1_cs>;
	status = "okay";

	spidev@0 {
		#address-cells = <1>;
		#size-cells = <1>;
		compatible = "linux,spidev";
		spi-max-frequency = <20000000>;
		reg = <0>;
	};
};
#endif /* CONFIG_NETDCUA9_SPI_A */

&fec {
	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_enet>;
	assigned-clocks = <&clks IMX6QDL_CLK_ENET_REF>;
	assigned-clock-rates = <50000000>;
	phy-mode = "rmii";
	phy-handle = <&ethphy0>;
	phy-supply = <&reg_vref_3v3>;
	status = "okay";

	mdio {
		#address-cells = <1>;
		#size-cells = <0>;

		ethphy0: ethernet-phy@1 {
			compatible = "ethernet-phy-ieee802.3-c22";
			reg = <1>;
			/* Set the maximum link speed if required */
			//max-speed = <100>;
			dp83848,led-activity;
			dp83848,auto-mdix;
		};
	};
};

&flexcan1 {
	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_flexcan1>;
	xceiver-supply = <&reg_can>;
	status = "okay";
};

&flexcan2 {
	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_flexcan2>;
	xceiver-supply = <&reg_can>;
	status = "okay";
};

&gpc {
	fsl,cpu_pupscr_sw2iso = <0xf>;
	fsl,cpu_pupscr_sw = <0xf>;
	fsl,cpu_pdnscr_iso2sw = <0x1>;
	fsl,cpu_pdnscr_iso = <0x1>;
	fsl,ldo-bypass = <0>; /* use ldo-bypass, u-boot will check it and configure */
	fsl,wdog-reset = <1>; /* watchdog select of reset source */
};

#ifdef CONFIG_NETDCUA9_I2C_C
&i2c1 {
	clock-frequency = <100000>;
	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_i2c1>;
	status = "okay";

	rtc8565@51 {
		compatible = "nxp,pcf8565", "nxp,pcf8563";
		reg = <0x51>;
		interrupt-parent = <&gpio1>;
		interrupts = <23 IRQ_TYPE_EDGE_FALLING>;
	};

#if 0 //### todo
#ifdef CONFIG_NETDCUA9_PARALLEL_CAMERA
	ov9665: ov9665@30 {
		compatible = "ovti,ov9665";
		reg = <0x30>;
		pinctrl-names = "default";
		pinctrl-0 = <&pinctrl_ipu1_2>;
		clocks = <&clks IMX6QDL_CLK_CKO>;
		clock-names = "csi_mclk";
		DOVDD-supply = <&reg_camera_dovdd>; /* 1.8v */
		AVDD-supply = <&reg_camera_avdd>;  /* 2.8v, rev C board is VGEN3
						rev B board is VGEN5 */
		DVDD-supply = <&reg_camera_dvdd>;  /* 1.5v*/
		//pwn-gpios = <&gpio5 24 GPIO_ACTIVE_HIGH>;
		//rst-gpios = <&gpio5 23 GPIO_ACTIVE_LOW>;
		csi_id = <0>;
		mclk = <24000000>;
		mclk_source = <0>;
	};
#endif /* CONFIG_NETDCUA9_PARALLEL_CAMERA */
#endif
};
#endif /* CONFIG_NETDCUA9_I2C_C */

#ifdef CONFIG_NETDCUA9_I2C_A
&i2c2 {
	clock-frequency = <100000>;
	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_i2c2>;
	status = "okay";

#ifdef CONFIG_NETDCUA9_BT656
	adv739x@2b {
		compatible = "adi,adv7391";
		reg = <0x2b>;
	};
#endif

#ifdef CONFIG_NETDCUA9_CAPTOUCH_MXT224
	/* Atmel PCAP touch on Touch-Connector (I2C) */
	mxt224@4a {
		compatible = "atmel,maxtouch";
		reg = <0x4a>;
		interrupt-parent = <&gpio1>;
		interrupts = <7 IRQ_TYPE_EDGE_FALLING>;
		atmel,cfg_name = "atmel/mxt224.cfg";
		atmel,reset-gpio = <&gpio1 8 GPIO_ACTIVE_LOW>;
	};
#endif

#ifdef CONFIG_NETDCUA9_CAPTOUCH_FT5x06
	/* F&S driver V3.0 on Touch Connector (I2C) */
	ft5x06_ts@38 {
		compatible = "FocalTech,ft5306";
		reg = <0x38>;
		fingers = <2>;
		touchscreen-size-x = <800>;
		touchscreen-size-y = <480>;
		threshold = <25>;
		interrupt-parent = <&gpio1>;
		interrupts = <7 IRQ_TYPE_EDGE_FALLING>;
		reset-gpios = <&gpio1 8 GPIO_ACTIVE_LOW>;
		x-rev;
		y-rev;
		linux,wakeup;
	};
#endif

#ifdef CONFIG_NETDCUA9_CAPTOUCH_SITRONIX
	/* Sitronix PCAP touch on Touch-Connector (I2C) */
	st1633i@48 {
		compatible = "sitronix";
		reg = <0x48>;
		swap-xy;
		interrupt-parent = <&gpio1>;
		interrupts = <7 IRQ_TYPE_EDGE_FALLING>;
		reset-gpio = <&gpio1 8 GPIO_ACTIVE_LOW>;
	};
#endif

#ifdef CONFIG_NETDCUA9_CAPTOUCH_ILITEK
	/* Ilitek PCAP touch on Touch-Connector (I2C) */
	ili210x@41 {
		compatible = "Ilitek,ili210x";
		reg = <0x41>;
		interrupt-parent = <&gpio1>;
		interrupts = <7 IRQ_TYPE_EDGE_FALLING>;
		reset-gpio = <&gpio1 8 GPIO_ACTIVE_LOW>;
	};
#endif
};
#endif /* CONFIG_NETDCUA9_I2C_A */

#if defined (CONFIG_NETDCUA9_I2C_B) && !defined(CONFIG_NETDCUA9_SPI_A)
&i2c3 {
	clock-frequency = <100000>;
	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_i2c3>;
	status = "okay";
};
#endif /* CONFIG_NETDCUA9_I2C_B */

/* Backlight Control - PWM3 */
&pwm3 {
	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_pwm3>;
	#pwm-cells = <3>;
	keep-power;		/* Necessary if PWM is inverted */
	status = "okay";
};

&pwm4 {
	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_pwm4>;
	keep-power;		/* Necessary if PWM is inverted */
	status = "okay";
};

&dma_apbh {
	/* Switch to F&S implementation of APBH DMA driver for GPMI (NAND) */
	compatible = "fus,imx6-dma-apbh", "fus,imx28-dma-apbh";
	iram = <&ocram>;
};

#ifdef CONFIG_NETDCUA9_NAND
&gpmi {
	/* Switch to F&S implementation of GPMI NAND driver */
	compatible = "fus,imx6q-gpmi-nand";
	pinctrl-names = "default";
//###	pinctrl-0 = <&pinctrl_gpmi_nand_1>;
	fus,skipblocks = <2>;
	fus,chunk1k;
	fus,ecc_strength = <8>;		/* Spare area 64 bytes */
//###	fus,ecc_strength = <40>;	/* Spare area 224 bytes */
	status = "okay";
};
#endif

#ifdef CONFIG_NETDCUA9_WM9715_AUDIO
&audmux {
	status = "okay";
};

&ssi1 {
	fsl,mode = "ac97-slave";
	cell-index = <0>;
	pinctrl-names = "ac97-running", "ac97-reset", "ac97-warm-reset";
	pinctrl-0 = <&pinctrl_ac97_running>;
	pinctrl-1 = <&pinctrl_ac97_reset>;
	pinctrl-2 = <&pinctrl_ac97_warm_reset>;
	ac97-gpios = <&gpio1 14 0 &gpio1 13 0 &gpio3 8 0>;
	status = "okay";
};
#endif /* CONFIG_NETDCUA9_WM9715_AUDIO */

#ifdef CONFIG_NETDCUA9_UART_A
/* UART2 on pins 3,4,5,6 on J1 (debug port A)*/
&uart2 {
	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_uart2>;
	uart-has-rtscts;
	status = "okay";
};
#endif /* CONFIG_NETDCUA9_UART_A */

#ifdef CONFIG_NETDCUA9_UART_B
/* UART5 on pins 9/10 on J7 (port B) or RS485 on pins 20/24 on J1 */
&uart5 {
	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_uart5>;
#ifdef CONFIG_NETDCUA9_UART_B_RS485
	rs485-supply = <&reg_rs485>;
	uart-has-rtscts;
#endif
	status = "okay";
};
#endif /* CONFIG_NETDCUA9_UART_B */

#ifdef CONFIG_NETDCUA9_UART_C
/* UART4 on pins 12/14 on J5 (port C) */
&uart4 {
	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_uart4>;
	status = "okay";
};
#endif /* CONFIG_NETDCUA9_UART_C */

&usbotg {
	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_usbotg>;
#ifdef CONFIG_NETDCUA9_OTG_HOST
	dr_mode = "host";
	vbus-supply = <&reg_usb_otg_vbus>;
	disable-over-current;
#else
	dr_mode = "peripheral";
#endif
	status = "okay";
};

&usbh1 {
	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_usbh1>;
//###	vbus-supply = <&reg_usb_h1_vbus>;
	power-active-high;
	disable-over-current;
	status = "okay";
};


#ifdef CONFIG_NETDCUA9_SD_A
&usdhc1 {
	/* SD-Card-Slot, CD is active low, WP is active high */
	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_usdhc1_1>;
	cd-gpios = <&gpio1 1 GPIO_ACTIVE_LOW>;
	wp-gpios = <&gpio4 20 GPIO_ACTIVE_HIGH>;
	bus-width = <4>;
	vmmc-supply = <&reg_vref_3v3>;	/* VDD */
	vqmmc-supply = <&reg_vref_3v3>;	/* VDD_IO */
	voltage-ranges = <3300 3300>;
	no-1-8-v;
	keep-power-in-suspend;
	status = "okay";
};
#endif /* CONFIG_NETDCUA9_SD_A */

#ifdef CONFIG_NETDCUA9_EMMC
&usdhc3 {
	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_usdhc3>;
	non-removable;
	bus-width = <8>;
	vmmc-supply = <&reg_vref_3v3>;	/* VDD */
	vqmmc-supply = <&reg_vref_3v3>;	/* VDD_IO */
	voltage-ranges = <3300 3300>;
	no-1-8-v;
	keep-power-in-suspend;
	status = "okay";
};
#endif /* CONFIG_NETDCUA9_EMMC */

/* chipselect des eim auf cs 0 und cs 1 teilen */
&weim {
	#address-cells = <2>;
	#size-cells = <1>;
	ranges = <0 0 0x08000000 0x04000000>,
		 <1 0 0x0c000000 0x04000000>;
	fsl,weim-cs-gpr = <&gpr>;
	status = "okay";

	ax88796: ax88796 {
		compatible = "asix,ax88796-eth";
		reg = <1 0 0x40>;
		pinctrl-names = "default";
		pinctrl-0 = <&pinctrl_ax88796>;
		interrupt-parent = <&gpio3>;
		interrupts = <14 IRQ_TYPE_EDGE_FALLING>;
		rcr_val = <0x40>;
		dcr_val = <0x1>;
		gpoc_val = <0x19>;
		wordlength = <2>;
		mac-from-dev;

		fsl,weim-cs-timing = <0x00020001 0x00000000 0x16000202
					0x00000002 0x16002082 0x00000000>;
	};
};

#ifdef CONFIG_NETDCUA9_LCD
&lcd {
	/* LCD on NETDCUA9 is always on IPU1 (id=0), DI0 */
	ipu_id = <0>;
	disp_id = <0>;
	default_ifmt = CONFIG_NETDCUA9_LCD_PIX_FMT;
	status = "okay";
};
#endif

#ifdef CONFIG_NETDCUA9_BT656
&bt656 {
	/* BT656 on efusA9 is always on IPU1 (id=0), DI0 */
	ipu_id = <0>;
	disp_id = <0>;
	default_ifmt = CONFIG_NETDCUA9_BT656_PIX_FMT;
	status = "okay";
};
#endif

#if (defined(CONFIG_NETDCUA9_LVDS0) || defined(CONFIG_NETDCUA9_LVDS1))
&ldb {
	ext_ref;
#if defined(CONFIG_NETDCUA9_LVDS_SPLIT_MODE)
	split-mode;
#elif defined(CONFIG_NETDCUA9_LVDS_DUAL_MODE)
	dual-mode;
#endif
	ldb-supply = <&reg_vlcd>;
	status = "okay";

#ifdef CONFIG_NETDCUA9_LVDS0
	/* LVDS0 must always go to DI0 of an IPU! */
	lvds-channel@0 {
		reg = <0>;
#ifdef CONFIG_NETDCUA9_USE_ONE_IPU
		crtc = "ipu1-di0";
#else
		crtc = "ipu2-di0";
#endif
		fsl,data-mapping = CONFIG_NETDCUA9_LVDS0_MAPPING;
		fsl,data-width = <CONFIG_NETDCUA9_LVDS0_DATA_WIDTH>;
#ifdef __LVDS0_PRIMARY__
		primary;
#endif
		status = "okay";

		display-timings {
			native-mode = <&timing0>;
			timing0: CONFIG_NETDCUA9_LVDS0_TIMING;
		};
	};
#endif

#ifdef CONFIG_NETDCUA9_LVDS1
	/* LVDS1 must always go to DI1 of an IPU! */
	lvds-channel@1 {
#if defined(CONFIG_NETDCUA9_LVDS_DUAL_MODE) \
	|| defined(CONFIG_NETDCUA9_LVDS_SPLIT_MODE)
		reg = <0>;
#else
		reg = <1>;
#endif
#if (defined(CONFIG_NETDCUA9_USE_ONE_IPU) \
    || (__LVDS0_ON_0_OR_1__ && __LVDS1_ON_0_OR_1__) \
    || (__LVDS0_ON_2_OR_3__ && __LVDS1_ON_2_OR_3__))
		crtc = "ipu1-di1";
#else
		crtc = "ipu2-di1";
#endif
		fsl,data-mapping = CONFIG_NETDCUA9_LVDS1_MAPPING;
		fsl,data-width = <CONFIG_NETDCUA9_LVDS1_DATA_WIDTH>;
#ifdef __LVDS1_PRIMARY__
		primary;
#endif
		status = "okay";

		display-timings {
			native-mode = <&timing1>;
			timing1: CONFIG_NETDCUA9_LVDS1_TIMING;
		};
	};
#endif
};
#endif /* CONFIG_NETDCUA9_LVDS0 || CONFIG_NETDCUA9_LVDS1 */

&iomuxc {
	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_hog_1>;

	imx6qdl-netdcua9 {
		/* Pin configs that don't belong anywhere else */
		pinctrl_hog_1: hoggrp-1 {
			fsl,pins = <
				/* Audio clock */
				MX6QDL_PAD_GPIO_19__CCM_CLKO1		0x00031
				/* 5V_3V3n for VLCD */
				MX6QDL_PAD_GPIO_4__GPIO1_IO04		0x13059
				/* VLCD_ON for reg_vlcd */
				MX6QDL_PAD_SD4_DAT3__GPIO2_IO11		0x13059
				/* VBL_ON on J12  */
				MX6QDL_PAD_SD4_DAT0__GPIO2_IO08		0x13059
				/* J5 ROW 0 - ROW 7, GPIO */
				MX6QDL_PAD_EIM_A16__GPIO2_IO22		0x030b0
				MX6QDL_PAD_EIM_A17__GPIO2_IO21		0x030b0
				MX6QDL_PAD_EIM_A18__GPIO2_IO20		0x030b0
				MX6QDL_PAD_EIM_A19__GPIO2_IO19		0x030b0
				MX6QDL_PAD_EIM_A20__GPIO2_IO18		0x030b0
				MX6QDL_PAD_EIM_A21__GPIO2_IO17		0x030b0
				MX6QDL_PAD_EIM_A22__GPIO2_IO16		0x030b0
				MX6QDL_PAD_EIM_A23__GPIO6_IO06		0x030b0
				/* J5 COL 0 - COL 7, GPIO */
				MX6QDL_PAD_EIM_A24__GPIO5_IO04		0x030b0
				MX6QDL_PAD_EIM_A25__GPIO5_IO02		0x030b0
				MX6QDL_PAD_EIM_EB2__GPIO2_IO30		0x030b0
				MX6QDL_PAD_EIM_EB3__GPIO2_IO31		0x030b0
				MX6QDL_PAD_EIM_BCLK__GPIO6_IO31		0x030b0
				MX6QDL_PAD_EIM_WAIT__GPIO5_IO00		0x030b0
				MX6QDL_PAD_EIM_EB0__GPIO2_IO28		0x030b0
				MX6QDL_PAD_EIM_EB1__GPIO2_IO29		0x030b0
				/* J5 KBINT */
				MX6QDL_PAD_EIM_DA10__GPIO3_IO10		0x030b0
				/* DVS */
				MX6QDL_PAD_EIM_DA13__GPIO3_IO13		0x00000
				/* LCD DEN */
				MX6QDL_PAD_CSI0_DATA_EN__GPIO5_IO20	0x1b0b0
				/* IRQ1 for SX8654 and WM9715 (ADC) */
				MX6QDL_PAD_EIM_DA5__GPIO3_IO05		0x030b0
				/* IRQ2 for ADS1015 and WM9715 (GENIRQ) */
				MX6QDL_PAD_EIM_DA6__GPIO3_IO06		0x030b0
				/* IRQ3 for WM9715 (PENDOWN) */
				MX6QDL_PAD_EIM_DA7__GPIO3_IO07		0x030b0
				/* RTC_IRQ */
				MX6QDL_PAD_ENET_REF_CLK__GPIO1_IO23	0x0b0b0
				/* I2C2 IRQ */
				MX6QDL_PAD_GPIO_7__GPIO1_IO07		0x0b0b0
				/* I2C2 RST */
				MX6QDL_PAD_GPIO_8__GPIO1_IO08		0x0b0b0
			>;
		};

#if 0
		/* Pins already set in bootloader */
		pinctrl_gpmi_nand_1: gpmi-nand-1 {
			fsl,pins = <
				MX6QDL_PAD_NANDF_CLE__NAND_CLE		0x0b0b1
				MX6QDL_PAD_NANDF_ALE__NAND_ALE		0x0b0b1
				MX6QDL_PAD_NANDF_WP_B__NAND_WP_B	0x0b0b1
				MX6QDL_PAD_NANDF_RB0__NAND_READY_B	0x0b000
				MX6QDL_PAD_NANDF_CS0__NAND_CE0_B	0x0b0b1
				MX6QDL_PAD_SD4_CMD__NAND_RE_B		0x0b0b1
				MX6QDL_PAD_SD4_CLK__NAND_WE_B		0x0b0b1
				MX6QDL_PAD_NANDF_D0__NAND_DATA00	0x0b0b1
				MX6QDL_PAD_NANDF_D1__NAND_DATA01	0x0b0b1
				MX6QDL_PAD_NANDF_D2__NAND_DATA02	0x0b0b1
				MX6QDL_PAD_NANDF_D3__NAND_DATA03	0x0b0b1
				MX6QDL_PAD_NANDF_D4__NAND_DATA04	0x0b0b1
				MX6QDL_PAD_NANDF_D5__NAND_DATA05	0x0b0b1
				MX6QDL_PAD_NANDF_D6__NAND_DATA06	0x0b0b1
				MX6QDL_PAD_NANDF_D7__NAND_DATA07	0x0b0b1
			>;
		};
#endif

#ifdef CONFIG_NETDCUA9_LCD
		/* LCD interface */
		pinctrl_ipu1_ctrl: ipu1grp-1 {
			fsl,pins = <
				MX6QDL_PAD_DI0_DISP_CLK__IPU1_DI0_DISP_CLK 0x10
				MX6QDL_PAD_DI0_PIN2__IPU1_DI0_PIN02	   0x10
				MX6QDL_PAD_DI0_PIN3__IPU1_DI0_PIN03	   0x10
				MX6QDL_PAD_DI0_PIN15__IPU1_DI0_PIN15	   0x10
			>;
		};

		pinctrl_ipu1_dat: ipu1grp-2 {
			fsl,pins = <
			/* LCD interface */
				MX6QDL_PAD_DISP0_DAT0__IPU1_DISP0_DATA00   0x10
				MX6QDL_PAD_DISP0_DAT1__IPU1_DISP0_DATA01   0x10
				MX6QDL_PAD_DISP0_DAT2__IPU1_DISP0_DATA02   0x10
				MX6QDL_PAD_DISP0_DAT3__IPU1_DISP0_DATA03   0x10
				MX6QDL_PAD_DISP0_DAT4__IPU1_DISP0_DATA04   0x10
				MX6QDL_PAD_DISP0_DAT5__IPU1_DISP0_DATA05   0x10
				MX6QDL_PAD_DISP0_DAT6__IPU1_DISP0_DATA06   0x10
				MX6QDL_PAD_DISP0_DAT7__IPU1_DISP0_DATA07   0x10
				MX6QDL_PAD_DISP0_DAT8__IPU1_DISP0_DATA08   0x10
				MX6QDL_PAD_DISP0_DAT9__IPU1_DISP0_DATA09   0x10
				MX6QDL_PAD_DISP0_DAT10__IPU1_DISP0_DATA10  0x10
				MX6QDL_PAD_DISP0_DAT11__IPU1_DISP0_DATA11  0x10
				MX6QDL_PAD_DISP0_DAT12__IPU1_DISP0_DATA12  0x10
				MX6QDL_PAD_DISP0_DAT13__IPU1_DISP0_DATA13  0x10
				MX6QDL_PAD_DISP0_DAT14__IPU1_DISP0_DATA14  0x10
				MX6QDL_PAD_DISP0_DAT15__IPU1_DISP0_DATA15  0x10
				MX6QDL_PAD_DISP0_DAT16__IPU1_DISP0_DATA16  0x10
				MX6QDL_PAD_DISP0_DAT17__IPU1_DISP0_DATA17  0x10
				MX6QDL_PAD_DISP0_DAT18__IPU1_DISP0_DATA18  0x10
				MX6QDL_PAD_DISP0_DAT19__IPU1_DISP0_DATA19  0x10
				MX6QDL_PAD_DISP0_DAT20__IPU1_DISP0_DATA20  0x10
				MX6QDL_PAD_DISP0_DAT21__IPU1_DISP0_DATA21  0x10
				MX6QDL_PAD_DISP0_DAT22__IPU1_DISP0_DATA22  0x10
				MX6QDL_PAD_DISP0_DAT23__IPU1_DISP0_DATA23  0x10
			>;
		};
#endif

#ifdef CONFIG_NETDCUA9_BT656
		pinctrl_ipu1_bt656: ipu1grp-3 {
			fsl,pins = <
				MX6QDL_PAD_DI0_DISP_CLK__IPU1_DI0_DISP_CLK 0x10
				MX6QDL_PAD_DISP0_DAT0__IPU1_DISP0_DATA00   0x10
				MX6QDL_PAD_DISP0_DAT1__IPU1_DISP0_DATA01   0x10
				MX6QDL_PAD_DISP0_DAT2__IPU1_DISP0_DATA02   0x10
				MX6QDL_PAD_DISP0_DAT3__IPU1_DISP0_DATA03   0x10
				MX6QDL_PAD_DISP0_DAT4__IPU1_DISP0_DATA04   0x10
				MX6QDL_PAD_DISP0_DAT5__IPU1_DISP0_DATA05   0x10
				MX6QDL_PAD_DISP0_DAT6__IPU1_DISP0_DATA06   0x10
				MX6QDL_PAD_DISP0_DAT7__IPU1_DISP0_DATA07   0x10			
			>;
		};
#endif

#if 0 //### todo
#ifdef CONFIG_NETDCUA9_PARALLEL_CAMERA
		pinctrl_ipu1_2: ipu1grp-cam { /* parallel camera */
			fsl,pins = <
				MX6QDL_PAD_CSI0_DAT12__IPU1_CSI0_DATA12	0x1b0b0
				MX6QDL_PAD_CSI0_DAT13__IPU1_CSI0_DATA13	0x1b0b0
				MX6QDL_PAD_CSI0_DAT14__IPU1_CSI0_DATA14	0x1b0b0
				MX6QDL_PAD_CSI0_DAT15__IPU1_CSI0_DATA15	0x1b0b0
				MX6QDL_PAD_CSI0_DAT16__IPU1_CSI0_DATA16	0x1b0b0
				MX6QDL_PAD_CSI0_DAT17__IPU1_CSI0_DATA17	0x1b0b0
				MX6QDL_PAD_CSI0_DAT18__IPU1_CSI0_DATA18	0x1b0b0
#if !defined(CONFIG_NETDCUA9_UART_D_RS485)
				MX6QDL_PAD_CSI0_DAT19__IPU1_CSI0_DATA19	0x1b0b0
#endif
				MX6QDL_PAD_CSI0_PIXCLK__IPU1_CSI0_PIXCLK 0x1b0b0
				MX6QDL_PAD_CSI0_MCLK__IPU1_CSI0_HSYNC	0x1b0b0
				MX6QDL_PAD_CSI0_VSYNC__IPU1_CSI0_VSYNC	0x1b0b0
			>;
		};
#endif /* CONFIG_NETDCUA9_PARALLEL_CAMERA */
#endif
/* not supported yet (FS Bus) */
#if 0 //### todo
		pinctrl_pif: pifgrp {
			fsl,pins = <
				MX6QDL_PAD_EIM_CS0__GPIO2_IO23		0x0
				MX6QDL_PAD_EIM_RW__GPIO2_IO26		0x0
				MX6QDL_PAD_EIM_D16__GPIO3_IO16		0x0
				MX6QDL_PAD_EIM_D17__GPIO3_IO17		0x0
				MX6QDL_PAD_EIM_D18__GPIO3_IO18		0x0
				MX6QDL_PAD_EIM_D19__GPIO3_IO19		0x0
				MX6QDL_PAD_EIM_D20__GPIO3_IO20		0x0
				MX6QDL_PAD_EIM_D21__GPIO3_IO21		0x0
				MX6QDL_PAD_EIM_D22__GPIO3_IO22		0x0
				MX6QDL_PAD_EIM_D23__GPIO3_IO23		0x0
				MX6QDL_PAD_EIM_DA12__GPIO3_IO12		0x0
				MX6QDL_PAD_EIM_DA11__GPIO3_IO11		0x0
				MX6QDL_PAD_EIM_DA12__EIM_AD12		0x0
			>;
	};
#endif

		pinctrl_ax88796: ax88796grp {
			fsl,pins = <
				/* AX88796B Ethernet 2 */
				MX6QDL_PAD_EIM_OE__EIM_OE_B 		0x000b0
				MX6QDL_PAD_EIM_CS1__EIM_CS1_B		0x000b0
				MX6QDL_PAD_EIM_RW__EIM_RW		0x000b0
				/* AX88796B Ethernet 2 IRQ */
				MX6QDL_PAD_EIM_DA14__GPIO3_IO14		0x0b0b0
				MX6QDL_PAD_EIM_DA15__GPIO3_IO15		0x030b0
				/* AX88796B Ethernet 2 RESET */
				MX6QDL_PAD_GPIO_3__GPIO1_IO03		0x0b0b0
				/* AX88796B Ethernet 2 - EIM_A */
				MX6QDL_PAD_EIM_DA0__EIM_AD00		0x0b0b0
				MX6QDL_PAD_EIM_DA1__EIM_AD01		0x0b0b0
				MX6QDL_PAD_EIM_DA2__EIM_AD02		0x0b0b0
				MX6QDL_PAD_EIM_DA3__EIM_AD03		0x0b0b0
				MX6QDL_PAD_EIM_DA4__EIM_AD04		0x0b0b0
				MX6QDL_PAD_EIM_DA12__EIM_AD12		0x0b0b0
				/* AX88796B Ethernet 2 - EIM_D & PIFDATA */
				MX6QDL_PAD_EIM_D16__EIM_DATA16		0x0b0b0
				MX6QDL_PAD_EIM_D17__EIM_DATA17		0x0b0b0
				MX6QDL_PAD_EIM_D18__EIM_DATA18		0x0b0b0
				MX6QDL_PAD_EIM_D19__EIM_DATA19		0x0b0b0
				MX6QDL_PAD_EIM_D20__EIM_DATA20		0x0b0b0
				MX6QDL_PAD_EIM_D21__EIM_DATA21		0x0b0b0
				MX6QDL_PAD_EIM_D22__EIM_DATA22		0x0b0b0
				MX6QDL_PAD_EIM_D23__EIM_DATA23		0x0b0b0
				MX6QDL_PAD_EIM_D24__EIM_DATA24		0x0b0b0
				MX6QDL_PAD_EIM_D25__EIM_DATA25		0x0b0b0
				MX6QDL_PAD_EIM_D26__EIM_DATA26		0x0b0b0
				MX6QDL_PAD_EIM_D27__EIM_DATA27		0x0b0b0
				MX6QDL_PAD_EIM_D28__EIM_DATA28		0x0b0b0
				MX6QDL_PAD_EIM_D29__EIM_DATA29		0x0b0b0
				MX6QDL_PAD_EIM_D30__EIM_DATA30		0x0b0b0
				MX6QDL_PAD_EIM_D31__EIM_DATA31		0x0b0b0
			>;
		};

#ifdef CONFIG_NETDCUA9_SPI_A
		/* ECSPI1  SPI_A */
		pinctrl_ecspi1_1: ecspi1grp {
			fsl,pins = <
				MX6QDL_PAD_CSI0_DAT5__ECSPI1_MOSI	0x100b1
				MX6QDL_PAD_CSI0_DAT6__ECSPI1_MISO	0x100b1
				MX6QDL_PAD_CSI0_DAT4__ECSPI1_SCLK	0x100b1
			>;
		};
		pinctrl_ecspi1_cs: ecspi1cs {
			fsl,pins = <
				/* ECSPI1_SS0 */
				MX6QDL_PAD_CSI0_DAT7__ECSPI1_SS0	0x1b0b0
			>;
		};
#endif /* CONFIG_NETDCUA9_SPI_A */

#ifdef CONFIG_NETDCUA9_UART_A
		/* UART2 on pins 3, 4, 5, 6 on J1 (debug port A) */
		pinctrl_uart2: uart2grp {
			fsl,pins = <
				MX6QDL_PAD_SD4_DAT7__UART2_TX_DATA	0x1b0b1
				MX6QDL_PAD_SD4_DAT4__UART2_RX_DATA	0x1b0b1
#ifdef CONFIG_NETDCUA9_UART_A_RTSCTS
				MX6QDL_PAD_SD4_DAT6__UART2_CTS_B	0x1b0b1
				MX6QDL_PAD_SD4_DAT5__UART2_RTS_B	0x1b0b1
#endif /* CONFIG_NETDCUA9_UART_A_RTSCTS */
			>;
		};
#endif /* CONFIG_NETDCUA9_UART_B */

#ifdef CONFIG_NETDCUA9_UART_B
		/* UART5 on pins 9, 10 on J7  (port B)*/
		pinctrl_uart5: uart5grp {
			fsl,pins = <
				MX6QDL_PAD_KEY_COL1__UART5_TX_DATA	0x1b0b1
				MX6QDL_PAD_KEY_ROW1__UART5_RX_DATA	0x1b0b1
#ifdef CONFIG_NETDCUA9_UART_B_RS485
				MX6QDL_PAD_CSI0_DAT19__UART5_CTS_B	0x1b0b1
				MX6QDL_PAD_EIM_DA9__GPIO3_IO09		0x1b0b1
#endif
			>;
		};
#endif /* CONFIG_NETDCUA9_UART_B */

#ifdef CONFIG_NETDCUA9_UART_C
		/* UART4 on pins 12, 14 on J5 (port C) */
		pinctrl_uart4: uart4grp {
			fsl,pins = <
				MX6QDL_PAD_KEY_COL0__UART4_TX_DATA	0x1b0b1
				MX6QDL_PAD_KEY_ROW0__UART4_RX_DATA	0x1b0b1
			>;
		};
#endif /* CONFIG_NETDCUA9_UART_C */

		/* CAN1 */
		pinctrl_flexcan1: flexcan1grp {
			fsl,pins = <
				MX6QDL_PAD_KEY_ROW2__FLEXCAN1_RX	0x1b020
				MX6QDL_PAD_KEY_COL2__FLEXCAN1_TX	0x1b020
			>;
		};
		/* CAN2 */
		pinctrl_flexcan2: flexcan2grp {
			fsl,pins = <
				MX6QDL_PAD_KEY_COL4__FLEXCAN2_TX	0x1b020
				MX6QDL_PAD_KEY_ROW4__FLEXCAN2_RX	0x1b020
			>;
		};

		pinctrl_usbotg: usbotggrp {
			fsl,pins = <
#ifdef CONFIG_NETDCUA9_OTG_HOST
				/* USB_OTG_PWR */
				MX6QDL_PAD_GPIO_9__GPIO1_IO09		0x03030
#endif
			>;
		};

		pinctrl_usbh1: usbh1grp {
			fsl,pins = <
				/* USB_H1_PWR*/
				MX6QDL_PAD_GPIO_0__USB_H1_PWR		0x03030
			>;
		};

		pinctrl_enet: enetgrp {
			fsl,pins = <
				MX6QDL_PAD_ENET_MDIO__ENET_MDIO		0x1b0b0
				MX6QDL_PAD_ENET_MDC__ENET_MDC		0x1b0b0
				MX6QDL_PAD_ENET_TXD0__ENET_TX_DATA0	0x1b0b0
				MX6QDL_PAD_ENET_TXD1__ENET_TX_DATA1	0x1b0b0
				MX6QDL_PAD_ENET_TX_EN__ENET_TX_EN	0x1b0b0
				MX6QDL_PAD_ENET_RXD0__ENET_RX_DATA0	0x1b0b0
				MX6QDL_PAD_ENET_RXD1__ENET_RX_DATA1	0x1b0b0
				MX6QDL_PAD_ENET_RX_ER__ENET_RX_ER	0x1b0b0
				MX6QDL_PAD_ENET_CRS_DV__ENET_RX_EN	0x1b0b0
				MX6QDL_PAD_GPIO_16__ENET_REF_CLK	0x4001b0b0
				/* Phy reset IO pin, value from UBoot */
				MX6QDL_PAD_GPIO_2__GPIO1_IO02		0x1b0b0
			>;
		};

#ifdef CONFIG_NETDCUA9_SD_A
		/* USDHC1 - SD A */
		pinctrl_usdhc1_1: usdhc1grp {
			fsl,pins = <
				MX6QDL_PAD_SD1_CMD__SD1_CMD		0x170b1
				MX6QDL_PAD_SD1_CLK__SD1_CLK		0x100b1
				MX6QDL_PAD_SD1_DAT0__SD1_DATA0		0x170b1
				MX6QDL_PAD_SD1_DAT1__SD1_DATA1		0x170b1
				MX6QDL_PAD_SD1_DAT2__SD1_DATA2		0x170b1
				MX6QDL_PAD_SD1_DAT3__SD1_DATA3		0x170b1
				/* Card Detect (CD), active low (pull-up) */
				MX6QDL_PAD_GPIO_1__GPIO1_IO01		0x17000
				/*
				 * Write Protect (WP), active high (pull-up)
				 * lock:   WP switch open, pulled high
				 * unlock: WP switch closed, connects to GND
				 */
				MX6QDL_PAD_DI0_PIN4__GPIO4_IO20		0x17000
			>;
		};
#endif /* CONFIG_NETDCUA9_SD_A */

		pinctrl_ac97_running: ac97_running {
			fsl,pins = <
				MX6QDL_PAD_SD2_DAT2__AUD4_TXD		0x170b9
				MX6QDL_PAD_SD2_DAT1__AUD4_TXFS		0x170b9
				MX6QDL_PAD_SD2_DAT0__AUD4_RXD		0x120f9
				MX6QDL_PAD_SD2_DAT3__AUD4_TXC		0x120f9
				MX6QDL_PAD_EIM_DA8__GPIO3_IO08		0x1b0b0
			>;
		};

		pinctrl_ac97_warm_reset: ac97_warm_reset {
			fsl,pins = <
				MX6QDL_PAD_SD2_DAT2__AUD4_TXD		0x170b9
				MX6QDL_PAD_SD2_DAT1__GPIO1_IO14		0x170b9
				MX6QDL_PAD_SD2_DAT0__AUD4_RXD		0x120f9
				MX6QDL_PAD_SD2_DAT3__AUD4_TXC		0x120f9
				MX6QDL_PAD_EIM_DA8__GPIO3_IO08		0x1b0b0
			>;
		};

		pinctrl_ac97_reset: ac97_reset {
			fsl,pins = <
				MX6QDL_PAD_SD2_DAT2__GPIO1_IO13		0x170b9
				MX6QDL_PAD_SD2_DAT1__GPIO1_IO14		0x170b9
				MX6QDL_PAD_SD2_DAT0__AUD4_RXD		0x120f9
				MX6QDL_PAD_SD2_DAT3__AUD4_TXC		0x120f9
				MX6QDL_PAD_EIM_DA8__GPIO3_IO08		0x1b0b0
			>;
		};

#ifdef CONFIG_NETDCUA9_I2C_C
		/* I2C_A: RTC (PCA8565), parallel camera */
		pinctrl_i2c1: i2c1grp-1 {
			fsl,pins = <
				MX6QDL_PAD_CSI0_DAT8__I2C1_SDA		0x4001b8b1
				MX6QDL_PAD_CSI0_DAT9__I2C1_SCL		0x4001b8b1
			>;
		};
#endif /* CONFIG_NETDCUA9_I2C_C */

#ifdef CONFIG_NETDCUA9_I2C_A
		/* I2C_A: Hirose (Touch) atmel-mxt224, focaltech */
		pinctrl_i2c2: i2c2grp-1 {
			fsl,pins = <
				MX6QDL_PAD_KEY_COL3__I2C2_SCL		0x4001b8b1
				MX6QDL_PAD_KEY_ROW3__I2C2_SDA		0x4001b8b1
			>;
		};
#endif /* CONFIG_NETDCUA9_I2C_A */

#if defined(CONFIG_NETDCUA9_I2C_B) && !defined(CONFIG_NETDCUA9_SPI_A)
		/* I2C_C: J5 Connector Pin 10/11 */
		pinctrl_i2c3: i2c3grp-1 {
			fsl,pins = <
				MX6QDL_PAD_GPIO_5__I2C3_SCL		0x4001b8b1
				MX6QDL_PAD_GPIO_6__I2C3_SDA		0x4001b8b1
			>;
		};
#endif /* CONFIG_NETDCUA9_I2C_B */

		/* Backlight Control - PWM3 */
		pinctrl_pwm3: pwm3grp {
			fsl,pins = <
				MX6QDL_PAD_SD4_DAT1__PWM3_OUT		0x110b0
			>;
		};
		/* PWM port A - PWM4 */
		pinctrl_pwm4: pwm4grp {
			fsl,pins = <
				MX6QDL_PAD_SD4_DAT2__PWM4_OUT		0x110b0
			>;
		};

#ifdef CONFIG_NETDCUA9_EMMC
		pinctrl_usdhc3: usdhc3grp {
			fsl,pins = <
				MX6QDL_PAD_SD3_CMD__SD3_CMD		0x17071
				MX6QDL_PAD_SD3_CLK__SD3_CLK		0x10071
				MX6QDL_PAD_SD3_DAT0__SD3_DATA0		0x17071
				MX6QDL_PAD_SD3_DAT1__SD3_DATA1		0x17071
				MX6QDL_PAD_SD3_DAT2__SD3_DATA2		0x17071
				MX6QDL_PAD_SD3_DAT3__SD3_DATA3		0x17071
				MX6QDL_PAD_SD3_DAT4__SD3_DATA4		0x17071
				MX6QDL_PAD_SD3_DAT5__SD3_DATA5		0x17071
				MX6QDL_PAD_SD3_DAT6__SD3_DATA6		0x17071
				MX6QDL_PAD_SD3_DAT7__SD3_DATA7		0x17071
				/* Reset eMMC, active low */
				MX6QDL_PAD_SD3_RST__SD3_RESET		0x1b071
			>;
		};
#endif /* CONFIG_NETDCUA9_EMMC */

		pinctrl_status_leds: ledgrp {
			fsl,pins = <
				MX6QDL_PAD_GPIO_17__GPIO7_IO12		0x30b0
				MX6QDL_PAD_GPIO_18__GPIO7_IO13		0x30b0
			>;
		};
	};
};
