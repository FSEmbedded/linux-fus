/*
 * Copyright 2016-2017 F&S Elektronik Systeme GmbH
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 */

#include <dt-bindings/pwm/pwm.h>

/*
 * When using one IPU, having LCD and LVDS0 at the same time is not possible,
 * because both devices would need to use display 0. But this can be simulated
 * by using LVDS1 instead of LVDS0 and activating Dual Mode.
 */
#ifdef CONFIG_EFUSA9_USE_ONE_IPU
#undef CONFIG_EFUSA9_MXCFB2
#undef CONFIG_EFUSA9_MXCFB3

#if ((CONFIG_EFUSA9_MXCFB0 == DISPLAY_LCD) && (CONFIG_EFUSA9_MXCFB1 == DISPLAY_LVDS0))
#undef CONFIG_EFUSA9_MXCFB1
#define CONFIG_EFUSA9_MXCFB1		DISPLAY_LVDS1
#define __MOVE_LVDS0_TO_LVDS1_DUAL_MODE__
#endif

#if ((CONFIG_EFUSA9_MXCFB0 == DISPLAY_LVDS0) && (CONFIG_EFUSA9_MXCFB1 == DISPLAY_LCD))
#undef CONFIG_EFUSA9_MXCFB0
#define CONFIG_EFUSA9_MXCFB0		DISPLAY_LVDS1
#define __MOVE_LVDS0_TO_LVDS1_DUAL_MODE__
#endif

#ifdef __MOVE_LVDS0_TO_LVDS1_DUAL_MODE__
#undef CONFIG_EFUSA9_LVDS1_MAPPING
#undef CONFIG_EFUSA9_LVDS1_BPP
#undef CONFIG_EFUSA9_LVDS1_PIX_FMT
#undef CONFIG_EFUSA9_LVDS1_DATA_WIDTH
#undef CONFIG_EFUSA9_LVDS1_TIMING
#define CONFIG_EFUSA9_LVDS1_MAPPING	CONFIG_EFUSA9_LVDS0_MAPPING
#define CONFIG_EFUSA9_LVDS1_BPP		CONFIG_EFUSA9_LVDS0_BPP
#define CONFIG_EFUSA9_LVDS1_PIX_FMT	CONFIG_EFUSA9_LVDS0_PIX_FMT
#define CONFIG_EFUSA9_LVDS1_DATA_WIDTH	CONFIG_EFUSA9_LVDS0_DATA_WIDTH
#define CONFIG_EFUSA9_LVDS1_TIMING	CONFIG_EFUSA9_LVDS0_TIMING
#ifndef CONFIG_EFUSA9_LVDS_DUAL_MODE
#define CONFIG_EFUSA9_LVDS_DUAL_MODE
#endif
#endif
#endif /* CONFIG_EFUSA9_USE_ONE_IPU */

/* Do we have LCD? */
#if ((CONFIG_EFUSA9_MXCFB0 == DISPLAY_LCD) \
    || (CONFIG_EFUSA9_MXCFB1 == DISPLAY_LCD) \
    || (CONFIG_EFUSA9_MXCFB2 == DISPLAY_LCD) \
    || (CONFIG_EFUSA9_MXCFB3 == DISPLAY_LCD))
#define CONFIG_EFUSA9_LCD
#if ((CONFIG_EFUSA9_MXCFB0 == DISPLAY_LCD) \
    || (CONFIG_EFUSA9_MXCFB1 == DISPLAY_LCD))
#define __LCD_ON_0_OR_1__	1
#define __LCD_ON_2_OR_3__	0
#else
#define __LCD_ON_0_OR_1__	0
#define __LCD_ON_2_OR_3__	1
#endif
#endif

/* Do we have HDMI? */
#if ((CONFIG_EFUSA9_MXCFB0 == DISPLAY_HDMI) \
    || (CONFIG_EFUSA9_MXCFB1 == DISPLAY_HDMI) \
    || (CONFIG_EFUSA9_MXCFB2 == DISPLAY_HDMI) \
    || (CONFIG_EFUSA9_MXCFB3 == DISPLAY_HDMI))
#define CONFIG_EFUSA9_HDMI
#define CONFIG_EFUSA9_HDMI_AUDIO
#define CONFIG_EFUSA9_HDMI_CEC
#if ((CONFIG_EFUSA9_MXCFB0 == DISPLAY_HDMI) \
    || (CONFIG_EFUSA9_MXCFB1 == DISPLAY_HDMI))
#define __HDMI_ON_0_OR_1__	1
#define __HDMI_ON_2_OR_3__	0
#else
#define __HDMI_ON_0_OR_1__	0
#define __HDMI_ON_2_OR_3__	1
#endif
#endif

/* Do we have LVDS0? */
#if ((CONFIG_EFUSA9_MXCFB0 == DISPLAY_LVDS0) \
    || (CONFIG_EFUSA9_MXCFB1 == DISPLAY_LVDS0) \
    || (CONFIG_EFUSA9_MXCFB2 == DISPLAY_LVDS0) \
    || (CONFIG_EFUSA9_MXCFB3 == DISPLAY_LVDS0))
#define CONFIG_EFUSA9_LVDS0
#if ((CONFIG_EFUSA9_MXCFB0 == DISPLAY_LVDS0) \
    || (CONFIG_EFUSA9_MXCFB1 == DISPLAY_LVDS0))
#define __LVDS0_ON_0_OR_1__	1
#define __LVDS0_ON_2_OR_3__	0
#else
#define __LVDS0_ON_0_OR_1__	0
#define __LVDS0_ON_2_OR_3__	1
#endif
#endif

/* Do we have LVDS1? */
#if ((CONFIG_EFUSA9_MXCFB0 == DISPLAY_LVDS1) \
    || (CONFIG_EFUSA9_MXCFB1 == DISPLAY_LVDS1) \
    || (CONFIG_EFUSA9_MXCFB2 == DISPLAY_LVDS1) \
    || (CONFIG_EFUSA9_MXCFB3 == DISPLAY_LVDS1))
#define CONFIG_EFUSA9_LVDS1
#if ((CONFIG_EFUSA9_MXCFB0 == DISPLAY_LVDS1) \
    || (CONFIG_EFUSA9_MXCFB1 == DISPLAY_LVDS1))
#define __LVDS1_ON_0_OR_1__	1
#define __LVDS1_ON_2_OR_3__	0
#else
#define __LVDS1_ON_0_OR_1__	0
#define __LVDS1_ON_2_OR_3__	1
#endif
#endif

/* Check which LVDS will be the primary display */
#if (CONFIG_EFUSA9_MXCFB0 == DISPLAY_LVDS0)
#define __LVDS0_PRIMARY__
#elif (CONFIG_EFUSA9_MXCFB0 == DISPLAY_LVDS1)
#define __LVDS1_PRIMARY__
#elif (CONFIG_EFUSA9_MXCFB1 == DISPLAY_LVDS0)
#define __LVDS0_PRIMARY__
#elif (CONFIG_EFUSA9_MXCFB1 == DISPLAY_LVDS1)
#define __LVDS1_PRIMARY__
#elif (CONFIG_EFUSA9_MXCFB2 == DISPLAY_LVDS0)
#define __LVDS0_PRIMARY__
#elif (CONFIG_EFUSA9_MXCFB2 == DISPLAY_LVDS1)
#define __LVDS1_PRIMARY__
#elif (CONFIG_EFUSA9_MXCFB3 == DISPLAY_LVDS0)
#define __LVDS0_PRIMARY__
#elif (CONFIG_EFUSA9_MXCFB3 == DISPLAY_LVDS1)
#define __LVDS1_PRIMARY__
#endif

/* Check for invalid CONFIG combinations */

/* If SD_A is not active, also CD and WP may not be used */
#ifndef CONFIG_EFUSA9_SD_A
#undef CONFIG_EFUSA9_SD_A_CD
#undef CONFIG_EFUSA9_SD_A_WP
#endif

/* If SD_B is not active, also CD and WP may not be used */
#ifndef CONFIG_EFUSA9_SD_B
#undef CONFIG_EFUSA9_SD_B_CD
#undef CONFIG_EFUSA9_SD_B_WP
#endif

/ {
	aliases {
		mxcfb0 = &mxcfb0;
		mxcfb1 = &mxcfb1;
		mxcfb2 = &mxcfb2;
		mxcfb3 = &mxcfb3;
	};

	memory {
		reg = <0x10000000 0x40000000>;
	};

	regulators {
		compatible = "simple-bus";

		reg_vref_3v3: regulator@0 {
			compatible = "regulator-fixed";
			regulator-name = "vref-3v3";
			regulator-min-microvolt = <3300000>;
			regulator-max-microvolt = <3300000>;
			regulator-always-on;
		};

		/* USB_OTG_PWR handled by USB controller, no regulator needed */
#if 0 //###
		reg_usb_otg_vbus: usb_otg_vbus {
			compatible = "regulator-fixed";
			regulator-name = "usb_otg_vbus";
			regulator-min-microvolt = <5000000>;
			regulator-max-microvolt = <5000000>;
			gpio = <&gpio3 22 0>;
		};
#endif //###

		/* USB_H1_PWR handled by USB controller, no regulator needed */
#if 0 //###
		reg_usb_h1_vbus: usb_h1_vbus {
			compatible = "regulator-fixed";
			regulator-name = "usb_h1_vbus";
			regulator-min-microvolt = <5000000>;
			regulator-max-microvolt = <5000000>;
			gpio = <&gpio3 31 0>;
			enable-active-high;
		};
#endif //###

#ifdef CONFIG_EFUSA9_SGTL5000_AUDIO
		/* SGTL5000 analog voltage */
		reg_sgtl5000_vdda: sgtl5000_vdda {
			compatible = "regulator-fixed";
			regulator-name = "VDDA-supply";
			regulator-min-microvolt = <3000000>;
			regulator-max-microvolt = <3000000>;
			regulator-always-on;
		};

		/* SGTL5000 I/O voltage */
		reg_sgtl5000_vddio: sgtl5000_vddio {
			compatible = "regulator-fixed";
			regulator-name = "VDDIO-supply";
			regulator-min-microvolt = <3300000>;
			regulator-max-microvolt = <3300000>;
			regulator-always-on;
		};

		/* SGTL5000 internal digital voltage */
		reg_sgtl5000_vddd: sgtl5000_vddd {
			compatible = "regulator-fixed";
			regulator-name = "VDDD-supply";
			regulator-min-microvolt = <1500000>;
			regulator-max-microvolt = <1500000>;
			regulator-always-on;
		};
#endif /* CONFIG_EFUSA9_SGTL5000_AUDIO */

		reg_lcd_bl: backlight_lcd {
			compatible = "regulator-fixed";
			regulator-name = "lcd-bl";
			gpio = <&pca963x 0 GPIO_ACTIVE_HIGH>;
			regulator-min-microvolt = <3300000>;
			regulator-max-microvolt = <3300000>;
		};

		reg_ldb_bl: backlight_ldb {
			compatible = "regulator-fixed";
			regulator-name = "ldb-bl";
			gpio = <&gpio2 8 GPIO_ACTIVE_HIGH>;
			regulator-min-microvolt = <3300000>;
			regulator-max-microvolt = <3300000>;
			enable-active-high;
		};

		/* LCD power on voltage */
		reg_vlcd: vlcd {
			compatible = "regulator-fixed";
			regulator-name = "VLCD";
			gpio = <&gpio2 11 GPIO_ACTIVE_HIGH>;
			regulator-min-microvolt = <3300000>;
			regulator-max-microvolt = <3300000>;
			enable-active-high;
		};

#ifdef CONFIG_EFUSA9_5V_LVDS
		/* Switching LVDS power from 3.3V to 5V is available since
		   board rev. 1.21; on earlier board revisions, this GPIO is
		   not connected and has no effect */
		reg_vlcd_5V: vlcd-5V {
			compatible = "regulator-fixed";
			regulator-name = "VLCD-5V";
			gpio = <&gpio3 30 GPIO_ACTIVE_HIGH>;
		};
#endif

		/* CAN */
		reg_can: regulator_can {
			compatible = "regulator-fixed";
			regulator-name = "can";
		};

#ifdef CONFIG_EFUSA9_CAMERA
		reg_camera_dovdd: camera_dovdd {
			compatible = "regulator-fixed";
			regulator-name = "DOVDD-supply";
			regulator-min-microvolt = <1800000>;
			regulator-max-microvolt = <1800000>;
		};

		reg_camera_avdd: camera_avdd {
			compatible = "regulator-fixed";
			regulator-name = "VAVDD-supply";
			regulator-min-microvolt = <2800000>;
			regulator-max-microvolt = <2800000>;
		};

		reg_camera_dvdd: camera_dvdd {
			compatible = "regulator-fixed";
			regulator-name = "DVDD-supply";
			regulator-min-microvolt = <1500000>;
			regulator-max-microvolt = <1500000>;
		};
#endif /* CONFIG_EFUSA9_CAMERA */
	};

	/* F&S board information */
	bdinfo: bdinfo {
		compatible = "bdinfo";
		board_name = "efusa9";
		ecc_strength = "8";
	};
#ifdef CONFIG_EFUSA9_SGTL5000_AUDIO
	sound {
		compatible = "fsl,imx-audio-sgtl5000";
		cpu-dai = <&ssi1>;
		audio-codec = <&sgtl5000>;
		model = "imx-sgtl5000";
		mux-int-port = <1>;  /* SSI1=1, SSI2=2, SSI3=7 */
		mux-ext-port = <4>;
		audio-routing =
//			"MIC_IN", "Mic Jack",
			"Mic Jack", "Mic Bias",
			"LINE_IN", "Line In Jack";
//			"Line Out Jack", "LINE_OUT";
	};
#endif

#ifdef CONFIG_EFUSA9_HDMI_AUDIO
	sound-hdmi {
		compatible = "fsl,imx6q-audio-hdmi", "fsl,imx-audio-hdmi";
		model = "imx-audio-hdmi";
		hdmi-controller = <&hdmi_audio>;
	};
#endif

	mxcfb0: fb@0 {
		compatible = "fsl,mxc_sdc_fb";
		late_init = <0>;
#if (CONFIG_EFUSA9_MXCFB0 == DISPLAY_LCD)
		disp_dev = "lcd";
		default_bpp = <CONFIG_EFUSA9_LCD_BPP>;
		interface_pix_fmt = CONFIG_EFUSA9_LCD_PIX_FMT;
		int_clk = <1>;
		mode_str = CONFIG_EFUSA9_LCD_MODE_STR;
#elif (CONFIG_EFUSA9_MXCFB0 == DISPLAY_HDMI)
		disp_dev = "hdmi";
		default_bpp = <CONFIG_EFUSA9_HDMI_BPP>;
		interface_pix_fmt = CONFIG_EFUSA9_HDMI_PIX_FMT;
		int_clk = <0>;
		mode_str = CONFIG_EFUSA9_HDMI_MODE_STR;
#elif (CONFIG_EFUSA9_MXCFB0 == DISPLAY_LVDS0)
		disp_dev = "ldb";
		default_bpp = <CONFIG_EFUSA9_LVDS0_BPP>;
		interface_pix_fmt = CONFIG_EFUSA9_LVDS0_PIX_FMT;
		int_clk = <1>;
#elif (CONFIG_EFUSA9_MXCFB0 == DISPLAY_LVDS1)
		disp_dev = "ldb";
		default_bpp = <CONFIG_EFUSA9_LVDS1_BPP>;
		interface_pix_fmt = CONFIG_EFUSA9_LVDS1_PIX_FMT;
		int_clk = <1>;
#else
		status = "disabled";
#endif
	};

	mxcfb1: fb@1 {
		compatible = "fsl,mxc_sdc_fb";
		late_init = <0>;
#if (CONFIG_EFUSA9_MXCFB1 == DISPLAY_LCD)
		disp_dev = "lcd";
		default_bpp = <CONFIG_EFUSA9_LCD_BPP>;
		interface_pix_fmt = CONFIG_EFUSA9_LCD_PIX_FMT;
		int_clk = <1>;
		mode_str = CONFIG_EFUSA9_LCD_MODE_STR;
#elif (CONFIG_EFUSA9_MXCFB1 == DISPLAY_HDMI)
		disp_dev = "hdmi";
		default_bpp = <CONFIG_EFUSA9_HDMI_BPP>;
		interface_pix_fmt = CONFIG_EFUSA9_HDMI_PIX_FMT;
		int_clk = <0>;
		mode_str = CONFIG_EFUSA9_HDMI_MODE_STR;
#elif (CONFIG_EFUSA9_MXCFB1 == DISPLAY_LVDS0)
		disp_dev = "ldb";
		default_bpp = <CONFIG_EFUSA9_LVDS0_BPP>;
		interface_pix_fmt = CONFIG_EFUSA9_LVDS0_PIX_FMT;
		int_clk = <1>;
#elif (CONFIG_EFUSA9_MXCFB1 == DISPLAY_LVDS1)
		disp_dev = "ldb";
		default_bpp = <CONFIG_EFUSA9_LVDS1_BPP>;
		interface_pix_fmt = CONFIG_EFUSA9_LVDS1_PIX_FMT;
		int_clk = <1>;
#else
		status = "disabled";
#endif
	};

	mxcfb2: fb@2 {
		compatible = "fsl,mxc_sdc_fb";
		late_init = <0>;
#if (CONFIG_EFUSA9_MXCFB2 == DISPLAY_LCD)
		disp_dev = "lcd";
		default_bpp = <CONFIG_EFUSA9_LCD_BPP>;
		interface_pix_fmt = CONFIG_EFUSA9_LCD_PIX_FMT;
		int_clk = <1>;
		mode_str = CONFIG_EFUSA9_LCD_MODE_STR;
#elif (CONFIG_EFUSA9_MXCFB2 == DISPLAY_HDMI)
		disp_dev = "hdmi";
		default_bpp = <CONFIG_EFUSA9_HDMI_BPP>;
		interface_pix_fmt = CONFIG_EFUSA9_HDMI_PIX_FMT;
		int_clk = <0>;
		mode_str = CONFIG_EFUSA9_HDMI_MODE_STR;
#elif (CONFIG_EFUSA9_MXCFB2 == DISPLAY_LVDS0)
		disp_dev = "ldb";
		default_bpp = <CONFIG_EFUSA9_LVDS0_BPP>;
		interface_pix_fmt = CONFIG_EFUSA9_LVDS0_PIX_FMT;
		int_clk = <1>;
#elif (CONFIG_EFUSA9_MXCFB2 == DISPLAY_LVDS1)
		disp_dev = "ldb";
		default_bpp = <CONFIG_EFUSA9_LVDS1_BPP>;
		interface_pix_fmt = CONFIG_EFUSA9_LVDS1_PIX_FMT;
		int_clk = <1>;
#else
		status = "disabled";
#endif
	};

	mxcfb3: fb@3 {
		compatible = "fsl,mxc_sdc_fb";
		late_init = <0>;
#if (CONFIG_EFUSA9_MXCFB3 == DISPLAY_LCD)
		disp_dev = "lcd";
		default_bpp = <CONFIG_EFUSA9_LCD_BPP>;
		interface_pix_fmt = CONFIG_EFUSA9_LCD_PIX_FMT;
		int_clk = <1>;
		mode_str = CONFIG_EFUSA9_LCD_MODE_STR;
#elif (CONFIG_EFUSA9_MXCFB3 == DISPLAY_HDMI)
		disp_dev = "hdmi";
		default_bpp = <CONFIG_EFUSA9_HDMI_BPP>;
		interface_pix_fmt = CONFIG_EFUSA9_HDMI_PIX_FMT;
		int_clk = <0>;
		mode_str = CONFIG_EFUSA9_HDMI_MODE_STR;
#elif (CONFIG_EFUSA9_MXCFB3 == DISPLAY_LVDS0)
		disp_dev = "ldb";
		default_bpp = <CONFIG_EFUSA9_LVDS0_BPP>;
		interface_pix_fmt = CONFIG_EFUSA9_LVDS0_PIX_FMT;
		int_clk = <1>;
#elif (CONFIG_EFUSA9_MXCFB3 == DISPLAY_LVDS1)
		disp_dev = "ldb";
		default_bpp = <CONFIG_EFUSA9_LVDS1_BPP>;
		interface_pix_fmt = CONFIG_EFUSA9_LVDS1_PIX_FMT;
		int_clk = <1>;
#else
		status = "disabled";
#endif
	};

	lcd: lcd@0 {
		compatible = "fsl,lcd";
		lcd-supply = <&reg_vlcd>;
		pinctrl-names = "default";
		pinctrl-0 = <&pinctrl_ipu1_ctrl &pinctrl_ipu1_dat>;
		status = "disabled";
	};

	/* RGB-LCD backlight PWM on RGB adapter */
	backlight_lcd {
		compatible = "pwm-backlight";
		pwms = <&pca963x 1 640000 PWM_POLARITY_INVERTED>;
		power-supply = <&reg_lcd_bl>;
		brightness-levels = <0 1 5 10 18 28 41 56
				     73 92 113 137 163 192 222 255>;
		default-brightness-level = <14>;
		fb-names = "mxs-lcdif1";
	};

	/* LVDS backlight PWM on backlight connector */
	backlight_ldb {
		compatible = "pwm-backlight";
		pwms = <&pwm3 0 5000000>;
		power-supply = <&reg_ldb_bl>;
		brightness-levels = <0 1 5 10 18 28 41 56
				     73 92 113 137 163 192 222 255>;
		default-brightness-level = <14>;
		fb-names = "mxs-lcdif2";
	};

#ifdef CONFIG_EFUSA9_CAMERA
#ifdef CONFIG_EFUSA9_PARALLEL_CAMERA
	/* Parallel digital camera interface */
	v4l2_cap_0 {
		compatible = "fsl,imx6q-v4l2-capture";
		ipu_id = <0>;
		csi_id = <0>;
		mclk_source = <0>;
		status = "okay";
	};
#endif

#ifdef CONFIG_EFUSA9_SERIAL_CAMERA
	/* Serial MIPI camera interface */
	v4l2_cap_1 {
		compatible = "fsl,imx6q-v4l2-capture";
		ipu_id = <0>;
		csi_id = <1>;
		mclk_source = <0>;
		status = "okay";
	};
#endif

	v4l2_out {
		compatible = "fsl,mxc_v4l2_output";
		status = "okay";
	};
#endif

	leds {
		compatible = "gpio-leds";
		pinctrl-names = "default";
		pinctrl-0 = <&pinctrl_status_leds>;

		status_1 {
			label = "Status1";
			gpios = <&gpio7 13 GPIO_ACTIVE_HIGH>;
			default-state = "keep";
		};

		status_2 {
			label = "Status2";
			gpios = <&gpio7 12 GPIO_ACTIVE_HIGH>;
			default-state = "keep";
		};
	};
};

/* RAM size for Continuous Memory Allocator; if not defined, use 320 MB */
#ifndef CONFIG_EFUSA9_CMA_SIZE
#define CONFIG_EFUSA9_CMA_SIZE 0x14000000
#endif
&cma {
	size = <CONFIG_EFUSA9_CMA_SIZE>;
};

&busfreq {
	/* Disable bus frequency scaling, because reducing bus frequency to
	   24 MHz does not work with all types of DDR3 RAM */
	disable-scaling;
};

#ifdef CONFIG_EFUSA9_SPI_B
/* SPI_B (3x CS) */
&ecspi1 {
	fsl,spi-num-chipselects = <3>;
	cs-gpios = <&gpio2 30 0>,	/* optional on-board SPI flash */
		<&gpio3 24 0>,		/* SPI_B_CS1 */
		<&gpio3 25 0>;		/* SPI_B_CS2 */

	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_ecspi1_1 &pinctrl_ecspi1_cs>;
	status = "okay";

	flash: m25p80@0 {
		#address-cells = <1>;
		#size-cells = <1>;
		compatible = "st,m25p32";
		spi-max-frequency = <20000000>;
		reg = <0>;
	};

	spidev@1 {
		#address-cells = <1>;
		#size-cells = <1>;
		compatible = "linux,spidev";
		spi-max-frequency = <20000000>;
		reg = <1>;
	};
	spidev@2 {
		#address-cells = <1>;
		#size-cells = <1>;
		compatible = "linux,spidev";
		spi-max-frequency = <20000000>;
		reg = <2>;
	};
};
#endif /* CONFIG_EFUSA9_SPI_B */

#ifdef CONFIG_EFUSA9_SPI_A
/* SPI_A (2x CS) */
&ecspi2 {
	fsl,spi-num-chipselects = <2>;
	cs-gpios = <&gpio2 26 0>,	/* SPI_A_CS1 */
		<&gpio2 27 0>;		/* SPI_A_CS2 */

	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_ecspi2_1 &pinctrl_ecspi2_cs>;
	status = "okay";
	spidev@0 {
		#address-cells = <1>;
		#size-cells = <1>;
		compatible = "linux,spidev";
		spi-max-frequency = <20000000>;
		reg = <0>;
	};
	spidev@1 {
		#address-cells = <1>;
		#size-cells = <1>;
		compatible = "linux,spidev";
		spi-max-frequency = <20000000>;
		reg = <1>;
	};
};
#endif /* CONFIG_EFUSA9_SPI_A */

&fec {
	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_enet>;
	phy-mode = "rgmii";
	phy-handle = <&ethphy0>;
	phy-supply = <&reg_vref_3v3>;
	status = "okay";

	mdio {
		#address-cells = <1>;
		#size-cells = <0>;

		ethphy0: ethernet-phy@4 {
			compatible = "ethernet-phy-ieee802.3-c22";
			reg = <4>;
			/* Set the maximum link speed if required */
			//max-speed = <100>;
		};
	};
};

&can1 {
	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_flexcan1_1>;
	xceiver-supply = <&reg_can>;
	status = "okay";
};

&can2 {
	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_flexcan2_1>;
	xceiver-supply = <&reg_can>;
	status = "okay";
};

&gpc {
	fsl,cpu_pupscr_sw2iso = <0xf>;
	fsl,cpu_pupscr_sw = <0xf>;
	fsl,cpu_pdnscr_iso2sw = <0x1>;
	fsl,cpu_pdnscr_iso = <0x1>;
	fsl,ldo-bypass = <0>; /* use ldo-bypass, u-boot will check it and configure */
	fsl,wdog-reset = <1>; /* watchdog select of reset source */
};

#ifdef CONFIG_EFUSA9_HDMI_AUDIO
&hdmi_audio {
	status = "okay";
};
#endif

#ifdef CONFIG_EFUSA9_HDMI_CEC
&hdmi_cec {
	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_hdmi_cec_1>;
	status = "okay";
};
#endif

#ifdef CONFIG_EFUSA9_HDMI
&hdmi_video {
	fsl,phy_reg_vlev = <0x0294>;
	fsl,phy_reg_cksymtx = <0x800d>;
	status = "okay";
};
#endif

#ifdef CONFIG_EFUSA9_I2C_C
&i2c1 {
	clock-frequency = <100000>;
	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_i2c1_2>;
	status = "okay";
#ifdef CONFIG_EFUSA9_SGTL5000_AUDIO
	sgtl5000: sgtl5000@0a {
		compatible = "fsl,sgtl5000";
		reg = <0x0a>;
		mono2both;
		/* derived from IMX6QDL_CLK_CKO2 */
		clocks = <&clks IMX6QDL_CLK_CKO>;
		VDDA-supply = <&reg_sgtl5000_vdda>;
		VDDIO-supply = <&reg_sgtl5000_vddio>;
		VDDD-supply = <&reg_sgtl5000_vddd>;
	};
#endif
#ifdef CONFIG_EFUSA9_HDMI
	hdmi: edid@50 {
		compatible = "fsl,imx6-hdmi-i2c";
		reg = <0x50>;
	};
#endif

	rtc8565@51 {
		compatible = "nxp,pcf8565", "nxp,pcf8563";
		reg = <0x51>;
		interrupt-parent = <&gpio1>;
		interrupts = <28 IRQ_TYPE_EDGE_FALLING>;
	};
#if 0 	//### FIXME
#ifdef CONFIG_EFUSA9_SERIAL_CAMERA
	ov564x_mipi: ov564x_mipi@3c {
		compatible = "ovti,ov564x_mipi";
		reg = <0x3c>;
		/* derived from IMX6QDL_CLK_CKO2 */
		clocks = <&clks IMX6QDL_CLK_CKO>;
		clock-names = "csi_mclk";
		DOVDD-supply = <&reg_camera_dovdd>; /* 1.8v */
		AVDD-supply = <&reg_camera_avdd>;  /* 2.8v, rev C board is VGEN3
						rev B board is VGEN5 */
		DVDD-supply = <&reg_camera_dvdd>;  /* 1.5v*/
		pwn-gpios = <&gpio5 24 GPIO_ACTIVE_HIGH>;
		/* not available */
		rst-gpios = <&gpio5 23 GPIO_ACTIVE_LOW>;
		csi_id = <1>;
		mclk = <24000000>;
		mclk_source = <0>;
	};
#endif /*  CONFIG_EFUSA9_SERIAL_CAMERA */
#endif //### FIXME

#ifdef CONFIG_EFUSA9_PARALLEL_CAMERA
	ov9665: ov9665@30 {
		compatible = "ovti,ov9665";
		reg = <0x30>;
		pinctrl-names = "default";
		pinctrl-0 = <&pinctrl_ipu1_2>;
		clocks = <&clks IMX6QDL_CLK_CKO>;
		clock-names = "csi_mclk";
		DOVDD-supply = <&reg_camera_dovdd>; /* 1.8v */
		AVDD-supply = <&reg_camera_avdd>;  /* 2.8v, rev C board is VGEN3
						rev B board is VGEN5 */
		DVDD-supply = <&reg_camera_dvdd>;  /* 1.5v*/
		pwn-gpios = <&gpio5 24 GPIO_ACTIVE_HIGH>;
		rst-gpios = <&gpio5 23 GPIO_ACTIVE_LOW>;
		csi_id = <0>;
		mclk = <24000000>;
		mclk_source = <0>;
	};
#endif /* CONFIG_EFUSA9_PARALLEL_CAMERA */
};
#endif /* CONFIG_EFUSA9_I2C_C */

#ifdef CONFIG_EFUSA9_I2C_A
&i2c2 {
	clock-frequency = <100000>;
	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_i2c2_2>;
	status = "okay";

	pca963x: pca9632@60 { /* LED-driver */
		compatible = "nxp,pca9632";
		reg = <0x60>;
		nxp,totem-pole;
		#address-cells = <1>;
		#size-cells = <0>;
		#pwm-cells = <3>;
		#gpio-cells = <2>;
		led@0 {
			reg = <0>;
			label = "0-PWRCTL";
			type = "GPIO";
			default-on;
			active-high;
		};
		led@1 {
			reg = <1>;
			label = "1-LEDCTRL";
			type = "PWM";
			default-on;
		};
		led@2 {
			reg = <2>;
			label = "2-ROTATE";
			type = "GPIO";
			active-high;
		};
		led@3 {
			reg = <3>;
			label = "3-unused";
			type = "LED";
		};
	};

#ifdef CONFIG_EFUSA9_4WTOUCH_SX8655_ONBOARD
	/* 4/5 wire analog resistive touch, controller on efus SKIT */
	sx8654@48 {
		compatible = "semtech,sx8654";
		reg = <0x48>;
		touchrate = <0x30>;
		powdly = <0x06>;
		filt = <0x02>;
		setdly = <0x08>;
		pinctrl-names = "default";
		/*pinctrl-0 = <&pinctrl_touchscreen>;*/
		interrupt-parent = <&gpio1>;
		interrupts = <30 IRQ_TYPE_EDGE_FALLING>;
	};
#endif

#ifdef CONFIG_EFUSA9_4WTOUCH_SX8655_RGBADAPTER
	/* 4/5 wire analog resistive touch, controller on efus SKIT */
	sx8654@49 {
		compatible = "semtech,sx8654";
		reg = <0x49>;
		touchrate = <0x30>;
		powdly = <0x06>;
		filt = <0x02>;
		setdly = <0x08>;
		pinctrl-names = "default";
		interrupt-parent = <&gpio1>;
		interrupts = <30 IRQ_TYPE_EDGE_FALLING>;
		reset-gpio = <&gpio1 29 GPIO_ACTIVE_LOW>;
	};
#endif

#ifdef CONFIG_EFUSA9_CAPTOUCH_FT5x06
	/* F&S driver V3.0 on Touch-Connector (I2C) */
	ft5x06_ts@38 {
		compatible = "FocalTech,ft5306";
		reg = <0x38>;
		fingers = <2>;
		touchscreen-size-x = <800>;
		touchscreen-size-y = <480>;
		threshold = <25>;
		interrupt-parent = <&gpio1>;
		interrupts = <30 IRQ_TYPE_EDGE_FALLING>;
		reset-gpio = <&gpio1 29 GPIO_ACTIVE_LOW>;
		linux,wakeup;
	};
#endif

#ifdef CONFIG_EFUSA9_CAPTOUCH_MXT224
	/* Atmel PCAP touch on Touch-Connector (I2C) */
	mxt224@4a {
		compatible = "atmel,maxtouch";
		reg = <0x4a>;
		interrupt-parent = <&gpio1>;
		interrupts = <30 IRQ_TYPE_EDGE_FALLING>;
		atmel,cfg_name = "atmel/mxt224.cfg";
		atmel,reset-gpio = <&gpio1 29 GPIO_ACTIVE_LOW>;
	};
#endif

#ifdef CONFIG_EFUSA9_CAPTOUCH_SITRONIX
	/* Sitronix PCAP touch on Touch-Connector (I2C) */
	st1633i@48 {
		compatible = "sitronix";
		reg = <0x48>;
		swap-xy;
		interrupt-parent = <&gpio1>;
		interrupts = <30 IRQ_TYPE_EDGE_FALLING>;
		reset-gpio = <&gpio1 29 GPIO_ACTIVE_LOW>;
	};
#endif

#ifdef CONFIG_EFUSA9_CAPTOUCH_ILINK
	/* Ilink PCAP touch on Touch-Connector (I2C) */
	ili210x@41 {
		compatible = "Ilink,ili210x";
		reg = <0x41>;
		interrupt-parent = <&gpio1>;
		interrupts = <30 IRQ_TYPE_EDGE_FALLING>;
		reset-gpio = <&gpio1 29 GPIO_ACTIVE_LOW>;
	};
#endif
};
#endif /* CONFIG_EFUSA9_I2C_A */


#ifdef CONFIG_EFUSA9_I2C_B
&i2c3 {
	clock-frequency = <100000>;
	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_i2c3_5>;
	status = "okay";
};
#endif /* CONFIG_EFUSA9_I2C_B */

&pwm3 {
	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_pwm3_1>;
	status = "okay";
};

&pwm4 {
	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_pwm4_1>;
	status = "okay";
};

&dma_apbh {
	/* Switch to F&S implementation of APBH DMA driver for GPMI (NAND) */
	compatible = "fus,imx6-dma-apbh", "fus,imx28-dma-apbh";
	iram = <&ocram>;
};

#ifdef CONFIG_EFUSA9_NAND
&gpmi {
	/* Switch to F&S implementation of GPMI NAND driver */
	compatible = "fus,imx6q-gpmi-nand";
	pinctrl-names = "default";
//###	pinctrl-0 = <&pinctrl_gpmi_nand_1>;
	fus,skipblocks = <2>;
	fus,chunk1k;
	fus,ecc_strength = <8>;		/* Spare area 64 bytes */
//###	fus,ecc_strength = <40>;	/* Spare area 224 bytes */
	status = "okay";
};
#endif

#ifdef CONFIG_EFUSA9_SERIAL_CAMERA
&mipi_csi {
	status = "okay";
	ipu_id = <0>;
	csi_id = <1>;
	v_channel = <0>;
	lanes = <2>;
};
#endif

#ifdef CONFIG_EFUSA9_SGTL5000_AUDIO
&audmux {
	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_audmux_4>;
	status = "okay";
};

&ssi1 {
	fsl,mode = "i2s-slave";
	status = "okay";
};
#endif /* CONFIG_EFUSA9_SGTL5000_AUDIO */

#ifdef CONFIG_EFUSA9_UART_A
/* UART4 (ttymxc3) on pins 94, 92 (debug port A) */
&uart4 {
	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_uart4_1>;
	status = "okay";
};
#endif /* CONFIG_EFUSA9_UART_A */

#ifdef CONFIG_EFUSA9_UART_B
/* UART2 on pins 104, 102, 106, 108 (port B)*/
&uart2 {
	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_uart2_1>;
#ifdef CONFIG_EFUSA9_UART_B_RTSCTS
	fsl,uart-has-rtscts;
#endif
	status = "okay";
};
#endif /* CONFIG_EFUSA9_UART_B */

#ifdef CONFIG_EFUSA9_UART_C
/* UART1 on pins 17, 15, 19, 21 (port C)*/
&uart1 {
	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_uart1_1>;
#ifdef CONFIG_EFUSA9_UART_C_RTSCTS
	fsl,uart-has-rtscts;
#endif
	status = "okay";
};
#endif

#ifdef CONFIG_EFUSA9_UART_D
/* UART5 on pins 98/96  (port D)*/
&uart5 {
	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_uart5_1>;
	status = "okay";
};
#endif /* CONFIG_EFUSA9_UART_D */

&usbotg {
	/* On efus-SKIT, OTG power is active low */
	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_usbotg>;
//###	vbus-supply = <&reg_usb_otg_vbus>;
#ifdef CONFIG_EFUSA9_HAVE_USB_OTG_OC
	over-current-active-low;
#else
	disable-over-current;
#endif
	status = "okay";
};

&usbh1 {
	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_usbh1>;
//###	vbus-supply = <&reg_usb_h1_vbus>;
	pwr-active-high;
	disable-over-current;
	status = "okay";
};

#ifdef CONFIG_EFUSA9_SD_A
&usdhc1 {
	/* On efus SKIT this is a Micro-SD card slot, CD active high, no WP */
	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_usdhc1_1>;
#ifdef CONFIG_EFUSA9_SD_A_CD
	cd-gpios = <&gpio1 1 GPIO_ACTIVE_LOW>;
#else
	non-removable;
#endif
#ifdef CONFIG_EFUSA9_SD_A_WP
	wp-gpios = <&gpio4 20 GPIO_ACTIVE_HIGH>;
#endif
	bus-width = <4>;
	vmmc-supply = <&reg_vref_3v3>;	/* VDD */
	vqmmc-supply = <&reg_vref_3v3>;	/* VDD_IO */
	voltage-ranges = <3300 3300>;
	no-1-8-v;
	keep-power-in-suspend;
	//enable-sdio-wakeup;
	status = "okay";
};
#endif /* CONFIG_EFUSA9_SD_A */

#ifdef CONFIG_EFUSA9_SD_B
&usdhc2 {
	/* SD-Card-Slot, CD is active low */
	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_usdhc2_2>;
#ifdef CONFIG_EFUSA9_SD_B_CD
	cd-gpios = <&gpio1 4 GPIO_ACTIVE_LOW>;
#else
	non-removable;
#endif
#ifdef CONFIG_EFUSA9_SD_B_WP
	wp-gpios = <&gpio1 2 GPIO_ACTIVE_HIGH>;
#endif
	bus-width = <4>;
	vmmc-supply = <&reg_vref_3v3>;	/* VDD */
	vqmmc-supply = <&reg_vref_3v3>;	/* VDD_IO */
	voltage-ranges = <3300 3300>;
	no-1-8-v;
	keep-power-in-suspend;
	//enable-sdio-wakeup;
	status = "okay";
};
#endif /* CONFIG_EFUSA9_SD_B */

#ifdef CONFIG_EFUSA9_EMMC
&usdhc3 {
	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_usdhc3>;
	non-removable;
	bus-width = <8>;
	vmmc-supply = <&reg_vref_3v3>;	/* VDD */
	vqmmc-supply = <&reg_vref_3v3>;	/* VDD_IO */
	voltage-ranges = <3300 3300>;
	no-1-8-v;
	status = "okay";
};
#endif /* CONFIG_EFUSA9_EMMC */


#ifdef CONFIG_EFUSA9_LCD
&lcd {
	/* LCD on efusA9 is always on IPU1 (id=0), DI0 */
	ipu_id = <0>;
	disp_id = <0>;
	default_ifmt = CONFIG_EFUSA9_LCD_PIX_FMT;
	status = "okay";
};
#endif

#ifdef CONFIG_EFUSA9_HDMI
&hdmi_core {
#ifdef CONFIG_EFUSA9_USE_ONE_IPU
	/*
	 * When using one IPU (id=0):
	 * HDMI can go to DI1, unless LVDS1 is also active. In this case LVDS1
	 * must go to DI1 and HDMI to DI0.
	 */
	ipu_id = <0>;
#if (__HDMI_ON_0_OR_1__ && __LVDS1_ON_0_OR_1__)
	disp_id = <0>;
#else
	disp_id = <1>;
#endif
#else /* !CONFIG_EFUSA9_USE_ONE_IPU */
	/*
	 * When using two IPUs:
	 * HDMI can always go to DI1. If HDMI is on MXCFB0 and LCD on MXCFB1,
	 * or vice versa, or HDMI is on MXCFB2 and LCD is on MXCFB3, or vice
	 * versa, then HDMI has to go to IPU2 (id=1), otherwise to IPU1 (id=0).
	 */
	disp_id = <1>;
#if ((__HDMI_ON_0_OR_1__ && __LCD_ON_0_OR_1__) \
    || (__HDMI_ON_2_OR_3__ && __LCD_ON_2_OR_3__))
	ipu_id = <1>;
#else
	ipu_id = <0>;
#endif
#endif /* CONFIG_EFUSA9_USE_ONE_IPU */
	status = "okay";
};
#endif

#if (defined(CONFIG_EFUSA9_LVDS0) || defined(CONFIG_EFUSA9_LVDS1))
&ldb {
	ext_ref;
#if defined(CONFIG_EFUSA9_LVDS_SPLIT_MODE)
	split-mode;
#elif defined(CONFIG_EFUSA9_LVDS_DUAL_MODE)
	dual-mode;
#endif
	ldb-supply = <&reg_vlcd>;
	status = "okay";

#ifdef CONFIG_EFUSA9_LVDS0
	/* LVDS0 must always go to DI0 of an IPU! */
	lvds-channel@0 {
		reg = <0>;
#ifdef CONFIG_EFUSA9_USE_ONE_IPU
		crtc = "ipu1-di0";
#else
		crtc = "ipu2-di0";
#endif
		fsl,data-mapping = CONFIG_EFUSA9_LVDS0_MAPPING;
		fsl,data-width = <CONFIG_EFUSA9_LVDS0_DATA_WIDTH>;
#ifdef __LVDS0_PRIMARY__
		primary;
#endif
		status = "okay";

		display-timings {
			native-mode = <&timing0>;
			timing0: CONFIG_EFUSA9_LVDS0_TIMING;
		};
	};
#endif

#ifdef CONFIG_EFUSA9_LVDS1
	/* LVDS1 must always go to DI1 of an IPU! */
	lvds-channel@1 {
#if defined(CONFIG_EFUSA9_LVDS_DUAL_MODE) \
	|| defined(CONFIG_EFUSA9_LVDS_SPLIT_MODE)
		reg = <0>;
#else
		reg = <1>;
#endif
#if (defined(CONFIG_EFUSA9_USE_ONE_IPU) \
    || (__LVDS0_ON_0_OR_1__ && __LVDS1_ON_0_OR_1__) \
    || (__LVDS0_ON_2_OR_3__ && __LVDS1_ON_2_OR_3__))
		crtc = "ipu1-di1";
#else
		crtc = "ipu2-di1";
#endif
		fsl,data-mapping = CONFIG_EFUSA9_LVDS1_MAPPING;
		fsl,data-width = <CONFIG_EFUSA9_LVDS1_DATA_WIDTH>;
#ifdef __LVDS1_PRIMARY__
		primary;
#endif
		status = "okay";

		display-timings {
			native-mode = <&timing1>;
			timing1: CONFIG_EFUSA9_LVDS1_TIMING;
		};
	};
#endif
};
#endif /* CONFIG_EFUSA9_LVDS0 || CONFIG_EFUSA9_LVDS1 */

&iomuxc {
	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_hog_1>;

	imx6qdl-efusa9 {
		/* Pin configs that don't belong anywhere else */
		pinctrl_hog_1: hoggrp-1 {
			fsl,pins = <
				/* Audio clock 24MHz */
				MX6QDL_PAD_GPIO_0__CCM_CLKO1		0x130b0
#if (CONFIG_EFUSA9_BOARD_REVISION >= 121)
				/* Camera clock 24MHz */
				MX6QDL_PAD_NANDF_CS2__CCM_CLKO2		0x130b0
				/* 5V_3V3n for VLCD */
				MX6QDL_PAD_EIM_D30__GPIO3_IO30		0x13059
#endif
				/* VLCD_ON for reg_vlcd */
				MX6QDL_PAD_SD4_DAT3__GPIO2_IO11		0x13059
				/* VBL_ON on SKIT J3  */
				MX6QDL_PAD_SD4_DAT0__GPIO2_IO08		0x13059
				/* WDOG1 */
				MX6QDL_PAD_GPIO_9__WDOG1_B		0x00008
				/* camera powerdown - active high */
				MX6QDL_PAD_CSI0_DAT6__GPIO5_IO24	0x17059
				/* camera reset - active low */
				MX6QDL_PAD_CSI0_DAT5__GPIO5_IO23	0x17059
				/* SW I2C on LVDS connector */
				MX6QDL_PAD_SD4_DAT6__GPIO2_IO14		0x4001b8b1
				MX6QDL_PAD_SD4_DAT7__GPIO2_IO15		0x4001b8b1
				/* I2C_A IRQ*/
				MX6QDL_PAD_ENET_TXD0__GPIO1_IO30	0x1b0b0
				/* I2C_A reset */
				MX6QDL_PAD_ENET_TXD1__GPIO1_IO29	0x1b0b0
			>;
		};

#if 0
		/* Pins already set in bootloader */
		pinctrl_gpmi_nand_1: gpmi-nand-1 {
			fsl,pins = <
				MX6QDL_PAD_NANDF_CLE__NAND_CLE		0x0b0b1
				MX6QDL_PAD_NANDF_ALE__NAND_ALE		0x0b0b1
				MX6QDL_PAD_NANDF_WP_B__NAND_WP_B	0x0b0b1
				MX6QDL_PAD_NANDF_RB0__NAND_READY_B	0x0b000
				MX6QDL_PAD_NANDF_CS0__NAND_CE0_B	0x0b0b1
				MX6QDL_PAD_SD4_CMD__NAND_RE_B		0x0b0b1
				MX6QDL_PAD_SD4_CLK__NAND_WE_B		0x0b0b1
				MX6QDL_PAD_NANDF_D0__NAND_DATA00	0x0b0b1
				MX6QDL_PAD_NANDF_D1__NAND_DATA01	0x0b0b1
				MX6QDL_PAD_NANDF_D2__NAND_DATA02	0x0b0b1
				MX6QDL_PAD_NANDF_D3__NAND_DATA03	0x0b0b1
				MX6QDL_PAD_NANDF_D4__NAND_DATA04	0x0b0b1
				MX6QDL_PAD_NANDF_D5__NAND_DATA05	0x0b0b1
				MX6QDL_PAD_NANDF_D6__NAND_DATA06	0x0b0b1
				MX6QDL_PAD_NANDF_D7__NAND_DATA07	0x0b0b1
			>;
		};
#endif

		/* LCD interface */
		pinctrl_ipu1_ctrl: ipu1grp-1 {
			fsl,pins = <
				MX6QDL_PAD_DI0_DISP_CLK__IPU1_DI0_DISP_CLK 0x00010
				MX6QDL_PAD_DI0_PIN2__IPU1_DI0_PIN02	0x00010
				MX6QDL_PAD_DI0_PIN3__IPU1_DI0_PIN03	0x00010
				MX6QDL_PAD_DI0_PIN15__IPU1_DI0_PIN15	0x00010
			>;
		};

		pinctrl_ipu1_dat: ipu1grp-2 {
			fsl,pins = <
			/* LCD interface */
				MX6QDL_PAD_DISP0_DAT0__IPU1_DISP0_DATA00   0x10
				MX6QDL_PAD_DISP0_DAT1__IPU1_DISP0_DATA01   0x10
				MX6QDL_PAD_DISP0_DAT2__IPU1_DISP0_DATA02   0x10
				MX6QDL_PAD_DISP0_DAT3__IPU1_DISP0_DATA03   0x10
				MX6QDL_PAD_DISP0_DAT4__IPU1_DISP0_DATA04   0x10
				MX6QDL_PAD_DISP0_DAT5__IPU1_DISP0_DATA05   0x10
				MX6QDL_PAD_DISP0_DAT6__IPU1_DISP0_DATA06   0x10
				MX6QDL_PAD_DISP0_DAT7__IPU1_DISP0_DATA07   0x10
				MX6QDL_PAD_DISP0_DAT8__IPU1_DISP0_DATA08   0x10
				MX6QDL_PAD_DISP0_DAT9__IPU1_DISP0_DATA09   0x10
				MX6QDL_PAD_DISP0_DAT10__IPU1_DISP0_DATA10  0x10
				MX6QDL_PAD_DISP0_DAT11__IPU1_DISP0_DATA11  0x10
				MX6QDL_PAD_DISP0_DAT12__IPU1_DISP0_DATA12  0x10
				MX6QDL_PAD_DISP0_DAT13__IPU1_DISP0_DATA13  0x10
				MX6QDL_PAD_DISP0_DAT14__IPU1_DISP0_DATA14  0x10
				MX6QDL_PAD_DISP0_DAT15__IPU1_DISP0_DATA15  0x10
				MX6QDL_PAD_DISP0_DAT16__IPU1_DISP0_DATA16  0x10
				MX6QDL_PAD_DISP0_DAT17__IPU1_DISP0_DATA17  0x10
			>;
		};

#ifdef CONFIG_EFUSA9_PARALLEL_CAMERA
		pinctrl_ipu1_2: ipu1grp-cam { /* parallel camera */
			fsl,pins = <
				MX6QDL_PAD_CSI0_DAT10__IPU1_CSI0_DATA10	0x80000000
				MX6QDL_PAD_CSI0_DAT11__IPU1_CSI0_DATA11	0x80000000
				MX6QDL_PAD_CSI0_DAT12__IPU1_CSI0_DATA12	0x80000000
				MX6QDL_PAD_CSI0_DAT13__IPU1_CSI0_DATA13	0x80000000
				MX6QDL_PAD_CSI0_DAT14__IPU1_CSI0_DATA14	0x80000000
				MX6QDL_PAD_CSI0_DAT15__IPU1_CSI0_DATA15	0x80000000
				MX6QDL_PAD_CSI0_DAT16__IPU1_CSI0_DATA16	0x80000000
				MX6QDL_PAD_CSI0_DAT17__IPU1_CSI0_DATA17	0x80000000
				MX6QDL_PAD_CSI0_DAT18__IPU1_CSI0_DATA18	0x80000000
				MX6QDL_PAD_CSI0_DAT19__IPU1_CSI0_DATA19	0x80000000
				MX6QDL_PAD_CSI0_PIXCLK__IPU1_CSI0_PIXCLK 0x80000000
				MX6QDL_PAD_CSI0_MCLK__IPU1_CSI0_HSYNC	0x80000000
				MX6QDL_PAD_CSI0_VSYNC__IPU1_CSI0_VSYNC	0x80000000
			>;
		};
#endif /* CONFIG_EFUSA9_PARALLEL_CAMERA */

#ifdef CONFIG_EFUSA9_SPI_A
		/* ECSPI2 - SPI_A */
		pinctrl_ecspi2_1: ecspi2grp {
			fsl,pins = <
				MX6QDL_PAD_EIM_OE__ECSPI2_MISO		0x100b1
				MX6QDL_PAD_EIM_CS1__ECSPI2_MOSI		0x100b1
				MX6QDL_PAD_EIM_CS0__ECSPI2_SCLK		0x100b1
			>;
		};
		pinctrl_ecspi2_cs: ecspi2cs {
			fsl,pins = <
				/* ECSPI2_SS0 - slave (chip) select 0 */
				MX6QDL_PAD_EIM_RW__GPIO2_IO26		0x1b0b0
				/* ECSPI2_SS1  - slave (chip) select 1 */
				MX6QDL_PAD_EIM_LBA__GPIO2_IO27		0x1b0b0
			>;
		};

		/* IRQs for SPI_A */
		pinctrl_espi2_1_irq: espi2_1_intgrp {
			fsl,pins = <
				MX6QDL_PAD_GPIO_7__GPIO1_IO07		0x1b0b0
			>;
		};

		pinctrl_espi2_2_irq: espi2_2_intgrp {
			fsl,pins = <
				MX6QDL_PAD_GPIO_8__GPIO1_IO08		0x1b0b0
			>;
		};

#endif /* CONFIG_EFUSA9_SPI_A */

#ifdef CONFIG_EFUSA9_SPI_B
		/* ECSPI1  SPI_B, SPI_Flash */
		pinctrl_ecspi1_1: ecspi1grp {
			fsl,pins = <
				MX6QDL_PAD_EIM_D17__ECSPI1_MISO		0x100b1
				MX6QDL_PAD_EIM_D18__ECSPI1_MOSI		0x100b1
				MX6QDL_PAD_EIM_D16__ECSPI1_SCLK		0x100b1
			>;
		};

		pinctrl_ecspi1_cs: ecspi1cs {
			fsl,pins = <
				/* ECSPI1_SS0  - SPI Flash slave (chip) select */
				MX6QDL_PAD_EIM_EB2__GPIO2_IO30		0x1b0b0
				/* ECSPI1_SS2  - slave (chip) select 1 */
				MX6QDL_PAD_EIM_D24__GPIO3_IO24		0x1b0b0
				/* ECSPI1_SS3  - slave (chip) select 2 */
				MX6QDL_PAD_EIM_D25__GPIO3_IO25		0x1b0b0
			>;
		};

		/* IRQs for SPI_B */
		pinctrl_espi1_1_irq: espi1_1_intgrp {
			fsl,pins = <
				MX6QDL_PAD_GPIO_5__GPIO1_IO05		0x1b0b0
			>;
		};

		pinctrl_espi1_2_irq: espi1_2_intgrp {
			fsl,pins = <
				MX6QDL_PAD_GPIO_6__GPIO1_IO06		0x1b0b0
			>;
		};
#endif /* CONFIG_EFUSA9_SPI_B */

#ifdef CONFIG_EFUSA9_UART_A
		/* UART4 (ttymxc3) on pins 94, 92 (debug port A) */
		pinctrl_uart4_1: uart4grp-1{
			fsl,pins = <
				MX6QDL_PAD_KEY_COL0__UART4_TX_DATA	0x1b0b1
				MX6QDL_PAD_KEY_ROW0__UART4_RX_DATA	0x1b0b1
			>;
		};
#endif /* CONFIG_EFUSA9_UART_A */

#ifdef CONFIG_EFUSA9_UART_B
		/* UART2 on pins 104, 102, 106, 108 (port B)*/
		pinctrl_uart2_1: uart2grp-1{
			fsl,pins = <
				MX6QDL_PAD_EIM_D26__UART2_TX_DATA	0x1b0b1
				MX6QDL_PAD_EIM_D27__UART2_RX_DATA	0x1b0b1
#ifdef CONFIG_EFUSA9_UART_B_RTSCTS
				MX6QDL_PAD_EIM_D28__UART2_CTS_B		0x1b0b1
				MX6QDL_PAD_EIM_D29__UART2_RTS_B		0x1b0b1
#endif /* CONFIG_EFUSA9_UART_B_RTSCTS */
			>;
		};
#endif /* CONFIG_EFUSA9_UART_B */

#ifdef CONFIG_EFUSA9_UART_C
		/* UART1 on pins 17, 15, 19, 21 (port C)*/
		pinctrl_uart1_1: uart1grp-1{
			fsl,pins = <
				/* shared pin with camera interface. s. HW */
				MX6QDL_PAD_CSI0_DAT10__UART1_TX_DATA	0x1b0b1
				/* shared pin with camera interface */
				MX6QDL_PAD_CSI0_DAT11__UART1_RX_DATA	0x1b0b1
#ifdef CONFIG_EFUSA9_UART_C_RTSCTS
				MX6QDL_PAD_EIM_D19__UART1_CTS_B		0x1b0b1
				MX6QDL_PAD_EIM_D20__UART1_RTS_B		0x1b0b1
#endif /* CONFIG_EFUSA9_UART_C_RTSCTS */
			>;
		};
#endif /* CONFIG_EFUSA9_UART_C */

#ifdef CONFIG_EFUSA9_UART_D
		/* UART5 on pins 98/96  (port D)*/
		pinctrl_uart5_1: uart5grp-1{
			fsl,pins = <
				MX6QDL_PAD_KEY_COL1__UART5_TX_DATA	0x1b0b1
				MX6QDL_PAD_KEY_ROW1__UART5_RX_DATA	0x1b0b1
			>;
		};
#endif /* CONFIG_EFUSA9_UART_D */

		/* CAN2 - CAN B */
		pinctrl_flexcan1_1: flexcan1grp {
			fsl,pins = <
				MX6QDL_PAD_KEY_ROW2__FLEXCAN1_RX	0x1b020
				MX6QDL_PAD_KEY_COL2__FLEXCAN1_TX	0x1b020
			>;
		};
		/* CAN1 - CAN A */
		pinctrl_flexcan2_1: flexcan2grp {
			fsl,pins = <
				MX6QDL_PAD_KEY_COL4__FLEXCAN2_TX	0x1b020
				MX6QDL_PAD_KEY_ROW4__FLEXCAN2_RX	0x1b020
			>;
		};

		pinctrl_usbotg: usbotggrp {
			fsl,pins = <
				/* USB_OTG_PWR, active low */
//###				MX6QDL_PAD_EIM_D22__GPIO3_IO22		0x0b030
				MX6QDL_PAD_EIM_D22__USB_OTG_PWR		0x0b030
#ifdef CONFIG_EFUSA9_HAVE_USB_OTG_OC
				/* USB_OTG_OC, active low */
				MX6QDL_PAD_EIM_D21__USB_OTG_OC		0x1b000
#endif
				/* USB_OTG_ID: low: host, open: device */
				MX6QDL_PAD_ENET_RX_ER__USB_OTG_ID 	0x1b000
			>;
		};

		pinctrl_usbh1: usbh1grp {
			fsl,pins = <
				/* USB_H1_PWR, active high */
//###				MX6QDL_PAD_EIM_D31__GPIO3_IO31		0x03030
				MX6QDL_PAD_EIM_D31__USB_H1_PWR		0x03030
			>;
		};

		pinctrl_enet: enetgrp {
			fsl,pins = <
				MX6QDL_PAD_ENET_MDIO__ENET_MDIO		0x1b0b0
				MX6QDL_PAD_ENET_MDC__ENET_MDC		0x1b0b0
				MX6QDL_PAD_RGMII_TXC__RGMII_TXC		0x1b0b0
				MX6QDL_PAD_RGMII_TD0__RGMII_TD0		0x1b0b0
				MX6QDL_PAD_RGMII_TD1__RGMII_TD1		0x1b0b0
				MX6QDL_PAD_RGMII_TD2__RGMII_TD2		0x1b0b0
				MX6QDL_PAD_RGMII_TD3__RGMII_TD3		0x1b0b0
				MX6QDL_PAD_RGMII_TX_CTL__RGMII_TX_CTL	0x1b0b0
				MX6QDL_PAD_ENET_REF_CLK__ENET_TX_CLK	0x1b0b0
				MX6QDL_PAD_RGMII_RXC__RGMII_RXC		0x1b0b0
				MX6QDL_PAD_RGMII_RD0__RGMII_RD0		0x1b0b0
				MX6QDL_PAD_RGMII_RD1__RGMII_RD1		0x1b0b0
				MX6QDL_PAD_RGMII_RD2__RGMII_RD2		0x1b0b0
				MX6QDL_PAD_RGMII_RD3__RGMII_RD3		0x1b0b0
				MX6QDL_PAD_RGMII_RX_CTL__RGMII_RX_CTL	0x1b0b0
				/* Phy interrupt IO pin*/
				MX6QDL_PAD_GPIO_19__GPIO4_IO05		0x4001b0a8
				/* Phy reset IO pin*/
				MX6QDL_PAD_ENET_CRS_DV__GPIO1_IO25	0x4001b0a8
			>;
		};
#ifdef CONFIG_EFUSA9_SD_A
		/* USDHC1 - SD A */
		pinctrl_usdhc1_1: usdhc1grp {
			fsl,pins = <
				MX6QDL_PAD_SD1_CMD__SD1_CMD		0x170b1
				MX6QDL_PAD_SD1_CLK__SD1_CLK		0x100b1
				MX6QDL_PAD_SD1_DAT0__SD1_DATA0		0x170b1
				MX6QDL_PAD_SD1_DAT1__SD1_DATA1		0x170b1
				MX6QDL_PAD_SD1_DAT2__SD1_DATA2		0x170b1
				MX6QDL_PAD_SD1_DAT3__SD1_DATA3		0x170b1
#ifdef CONFIG_EFUSA9_SD_A_CD
				/* Card Detect (CD), active low (pull-up) */
				MX6QDL_PAD_GPIO_1__GPIO1_IO01		0x17000
#endif
#ifdef CONFIG_EFUSA9_SD_A_WP
				/*
				 * Write Protect (WP), active high (pull-up)
				 * lock:   WP switch open, pulled high
				 * unlock: WP switch closed, connects to GND
				 */
				MX6QDL_PAD_DI0_PIN4__GPIO4_IO20		0x17000
#endif
			>;
		};
#endif /* CONFIG_EFUSA9_SD_A */

#ifdef CONFIG_EFUSA9_SD_B
		/* USDHC2 - SD B */
		pinctrl_usdhc2_2: usdhc2grp {
			fsl,pins = <
				MX6QDL_PAD_SD2_CMD__SD2_CMD		0x170b1
				MX6QDL_PAD_SD2_CLK__SD2_CLK		0x100b1
				MX6QDL_PAD_SD2_DAT0__SD2_DATA0		0x170b1
				MX6QDL_PAD_SD2_DAT1__SD2_DATA1		0x170b1
				MX6QDL_PAD_SD2_DAT2__SD2_DATA2		0x170b1
				MX6QDL_PAD_SD2_DAT3__SD2_DATA3		0x170b1
#ifdef CONFIG_EFUSA9_SD_B_CD
				/* Card Detect (CD), active low (pull-up) */
				MX6QDL_PAD_GPIO_4__GPIO1_IO04		0x17000
#endif
#ifdef CONFIG_EFUSA9_SD_B_WP
				/*
				 * Write Protect (WP), active high (pull-up)
				 * lock:   WP switch open, pulled high
				 * unlock: WP switch closed, connects to GND
				 */
				MX6QDL_PAD_GPIO_2__GPIO1_IO02		0x17000
#endif
			>;
		};
#endif /* CONFIG_EFUSA9_SD_B */

#ifdef CONFIG_EFUSA9_EMMC
		pinctrl_usdhc3: usdhc3grp {
			fsl,pins = <
				MX6QDL_PAD_SD3_CMD__SD3_CMD		0x17091
				MX6QDL_PAD_SD3_CLK__SD3_CLK		0x10091
				MX6QDL_PAD_SD3_DAT0__SD3_DATA0		0x17091
				MX6QDL_PAD_SD3_DAT1__SD3_DATA1		0x17091
				MX6QDL_PAD_SD3_DAT2__SD3_DATA2		0x17091
				MX6QDL_PAD_SD3_DAT3__SD3_DATA3		0x17091
				MX6QDL_PAD_SD3_DAT4__SD3_DATA4		0x17091
				MX6QDL_PAD_SD3_DAT5__SD3_DATA5		0x17091
				MX6QDL_PAD_SD3_DAT6__SD3_DATA6		0x17091
				MX6QDL_PAD_SD3_DAT7__SD3_DATA7		0x17091
				/* Reset eMMC, active low */
				MX6QDL_PAD_SD3_RST__SD3_RESET		0x17091
			>;
		};
#endif /* CONFIG_EFUSA9_EMMC */

#ifdef CONFIG_EFUSA9_I2C_C
		/* I2C_C: RTC (PCA8565), LVDS-Connector, SGTL5000 (SKIT),
		   Mini-PCIe (SKIT), Camera (SKIT, 2x) */
		pinctrl_i2c1_2: i2c1grp-1 {
			fsl,pins = <
				MX6QDL_PAD_CSI0_DAT8__I2C1_SDA		0x4001b8b1
				MX6QDL_PAD_CSI0_DAT9__I2C1_SCL		0x4001b8b1
			>;
		};
#endif /* CONFIG_EFUSA9_I2C_C */

#ifdef CONFIG_EFUSA9_I2C_A
		/* I2C_A: RGB-Connector (SKIT -> SX8655, LED-driver PCA9632),
		   Touch Connector (SKIT -> FT5x06, MXT), SX8655 (SKIT),
		   Feature Connector (SKIT) */
		pinctrl_i2c2_2: i2c2grp-1 {
			fsl,pins = <
				MX6QDL_PAD_KEY_COL3__I2C2_SCL		0x4001b8b1
				MX6QDL_PAD_KEY_ROW3__I2C2_SDA		0x4001b8b1
			>;
		};
#endif /* CONFIG_EFUSA9_I2C_A */

#ifdef CONFIG_EFUSA9_I2C_B
		/* I2C_B: Feature Connector (SKIT) */
		pinctrl_i2c3_5: i2c3grp-1 {
			fsl,pins = <
				MX6QDL_PAD_GPIO_3__I2C3_SCL		0x4001b8b1
				MX6QDL_PAD_GPIO_16__I2C3_SDA		0x4001b8b1
			>;
		};
#endif /* CONFIG_EFUSA9_I2C_B */

#if defined(CONFIG_EFUSA9_SGTL5000_AUDIO)
		pinctrl_audmux_4: audmux-4 {
			fsl,pins = <
				MX6QDL_PAD_DISP0_DAT20__AUD4_TXC	0x130b0
				MX6QDL_PAD_DISP0_DAT21__AUD4_TXD	0x130b0
				MX6QDL_PAD_DISP0_DAT22__AUD4_TXFS	0x130b0
				MX6QDL_PAD_DISP0_DAT23__AUD4_RXD	0x130b0
			>;
		};
#endif
		/* Backlight Control - PWM3 */
		pinctrl_pwm3_1: pwm3grp {
			fsl,pins = <
				MX6QDL_PAD_SD4_DAT1__PWM3_OUT		0x110b0
			>;
		};
		/* PWM port A - PWM4 */
		pinctrl_pwm4_1: pwm4grp {
			fsl,pins = <
				MX6QDL_PAD_SD4_DAT2__PWM4_OUT		0x110b0
			>;
		};

#ifdef CONFIG_EFUSA9_HDMI_CEC
		pinctrl_hdmi_cec_1: hdmicecgrp {
			fsl,pins = <
				MX6QDL_PAD_EIM_A25__HDMI_TX_CEC_LINE	0x1f8b0
			>;
		};
#endif /* CONFIG_EFUSA9_HDMI_CEC */

		pinctrl_status_leds: ledgrp {
			fsl,pins = <
				MX6QDL_PAD_GPIO_17__GPIO7_IO12		0x030b0
				MX6QDL_PAD_GPIO_18__GPIO7_IO13		0x030b0
			>;
		};
	};
};
